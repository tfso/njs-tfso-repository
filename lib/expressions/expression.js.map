{"version":3,"file":"expression.js","sourceRoot":"","sources":["../../src/expressions/expression.ts"],"names":[],"mappings":";AAWA,WAAY,cAAc;IACtB,2DAAQ,CAAA;IAER,+DAAU,CAAA;IACV,uDAAM,CAAA;IACN,yDAAO,CAAA;IACP,uDAAM,CAAA;IACN,qDAAK,CAAA;IACL,uDAAM,CAAA;IACN,yDAAO,CAAA;IACP,iEAAW,CAAA;IACX,qDAAK,CAAA;AACT,CAAC,EAZW,sBAAc,KAAd,sBAAc,QAYzB;AAZD,IAAY,cAAc,GAAd,sBAYX,CAAA;AAQD;IAGI,YAAY,IAAoB;QAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACtB,CAAC;IAED,IAAI,IAAI;QACJ,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAED,IAAI,IAAI,CAAC,KAAK;QACV,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,CAAC;IAEM,MAAM,CAAC,OAAY;QACtB,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,KAAK,cAAc,CAAC,OAAO;gBACvB,MAAM,CAAC,OAAO,CAAC,YAAY,CAA6B,IAAI,CAAC,CAAC;YAElE,KAAK,cAAc,CAAC,QAAQ;gBACxB,MAAM,CAAC,OAAO,CAAC,aAAa,CAA8B,IAAI,CAAC,CAAC;YAEpE,KAAK,cAAc,CAAC,UAAU;gBAC1B,MAAM,CAAC,OAAO,CAAC,eAAe,CAAgC,IAAI,CAAC,CAAC;YAExE,KAAK,cAAc,CAAC,MAAM;gBACtB,MAAM,CAAC,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;YAEhE,KAAK,cAAc,CAAC,MAAM;gBACtB,MAAM,CAAC,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;YAEhE,KAAK,cAAc,CAAC,KAAK;gBACrB,MAAM,CAAC,OAAO,CAAC,UAAU,CAA2B,IAAI,CAAC,CAAC;YAE9D,KAAK,cAAc,CAAC,MAAM;gBACtB,MAAM,CAAC,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;YAEhE,KAAK,cAAc,CAAC,OAAO;gBACvB,MAAM,CAAC,OAAO,CAAC,YAAY,CAA6B,IAAI,CAAC,CAAC;YAElE,KAAK,cAAc,CAAC,WAAW;gBAC3B,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAiC,IAAI,CAAC,CAAC;YAE1E,KAAK,cAAc,CAAC,KAAK;gBACrB,MAAM,CAAC,OAAO,CAAC,UAAU,CAA2B,IAAI,CAAC,CAAC;QAClE,CAAC;IACL,CAAC;AACL,CAAC;AAhDY,kBAAU,aAgDtB,CAAA;AAEiN","sourcesContent":["import { ILiteralExpression } from './literalexpression';\r\nimport { ICompoundExpression } from './compoundexpression';\r\nimport { IIdentifierExpression } from './identifierexpression';\r\nimport { IMemberExpression } from './memberexpression';\r\nimport { IMethodExpression } from './methodexpression';\r\nimport { IUnaryExpression } from './unaryexpression';\r\nimport { IBinaryExpression } from './binaryexpression';\r\nimport { ILogicalExpression } from './logicalexpression';\r\nimport { IConditionalExpression } from './conditionalexpression';\r\nimport { IArrayExpression } from './arrayexpression';\r\n\r\nexport enum ExpressionType {\r\n    Compound,\r\n\r\n    Identifier,\r\n    Member,\r\n    Literal,\r\n    Method,\r\n    Unary,\r\n    Binary,\r\n    Logical,\r\n    Conditional,\r\n    Array\r\n}\r\n\r\nexport interface IExpression {\r\n    type: ExpressionType\r\n\r\n    accept(visitor: any): IExpression\r\n}\r\n\r\nexport class Expression implements IExpression {\r\n    private _type: ExpressionType;\r\n\r\n    constructor(type: ExpressionType) { //(predicate: (it: Object) => boolean, parameters?: any) {\r\n        this._type = type;\r\n    }\r\n\r\n    get type() {\r\n        return this._type;\r\n    }\r\n\r\n    set type(value) {\r\n        this._type = value;\r\n    }\r\n\r\n    public accept(visitor: any) {\r\n        switch (this.type) {\r\n            case ExpressionType.Literal:\r\n                return visitor.visitLiteral(<ILiteralExpression><Object>this);\r\n\r\n            case ExpressionType.Compound:\r\n                return visitor.visitCompound(<ICompoundExpression><Object>this);\r\n\r\n            case ExpressionType.Identifier:\r\n                return visitor.visitIdentifier(<IIdentifierExpression><Object>this);\r\n\r\n            case ExpressionType.Member:\r\n                return visitor.visitMember(<IMemberExpression><Object>this);\r\n\r\n            case ExpressionType.Method:\r\n                return visitor.visitMethod(<IMethodExpression><Object>this);\r\n\r\n            case ExpressionType.Unary:\r\n                return visitor.visitUnary(<IUnaryExpression><Object>this);\r\n\r\n            case ExpressionType.Binary:\r\n                return visitor.visitBinary(<IBinaryExpression><Object>this);\r\n\r\n            case ExpressionType.Logical:\r\n                return visitor.visitLogical(<ILogicalExpression><Object>this);\r\n\r\n            case ExpressionType.Conditional:\r\n                return visitor.visitConditional(<IConditionalExpression><Object>this);\r\n\r\n            case ExpressionType.Array:\r\n                return visitor.visitArray(<IArrayExpression><Object>this);\r\n        }\r\n    }\r\n}\r\n\r\nexport { ILiteralExpression, ICompoundExpression, IIdentifierExpression, IMemberExpression, IMethodExpression, IUnaryExpression, IBinaryExpression, ILogicalExpression, IConditionalExpression, IArrayExpression }\r\n"]}