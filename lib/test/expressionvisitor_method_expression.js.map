{"version":3,"file":"expressionvisitor_method_expression.js","sourceRoot":"","sources":["../../src/test/expressionvisitor_method_expression.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\r\nimport * as Expr from './../linq/expressions/expressionvisitor';\r\n\r\ndescribe(\"When using ExpressionVisitor for method\", () => {\r\n    var visitor: Expr.ExpressionVisitor,\r\n        expr: Expr.IExpression;\r\n\r\n    beforeEach(() => {\r\n        visitor = new Expr.ExpressionVisitor;\r\n    })\r\n\r\n    describe(\"OData expression\", () => {\r\n\r\n        it(\"should return a method expression\", () => {\r\n            expr = visitor.visitOData(\"tolower(Country) eq 'NO'\");\r\n\r\n            assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n\r\n            assert.ok((<Expr.LogicalExpression>expr).left.type == Expr.ExpressionType.Method, \"Expected a MethodExpression at left side\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).name == \"tolower\", \"Expected method name 'tolower'\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).parameters.length == 1, \"Expected one argument\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).parameters[0].type == Expr.ExpressionType.Identifier, \"Expected a identifier as first argument\");\r\n        })\r\n\r\n        it(\"should return a method expression for nested methods\", () => {\r\n            expr = visitor.visitOData(\"concat(FCode, tolower(FText)) eq '2TEST'\");\r\n\r\n            assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n\r\n            assert.ok((<Expr.LogicalExpression>expr).left.type == Expr.ExpressionType.Method, \"Expected a MethodExpression at left side\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).name == \"concat\", \"Expected method name 'concat'\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).parameters.length == 2, \"Expected two arguments\");\r\n\r\n            assert.ok(((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).parameters[0]).type == Expr.ExpressionType.Identifier, \"Expected a identifier for first argument\");\r\n\r\n            assert.ok(((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).parameters[1]).type == Expr.ExpressionType.Method, \"Expected a method for second argument\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).parameters[1])).name == \"tolower\", \"Expected method name 'tolower' for second argument\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).parameters[1])).parameters.length == 1, \"Expected one argument in method for second argument\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.IMethodExpression>((<Expr.LogicalExpression>expr).left)).parameters[1])).parameters[0].type == Expr.ExpressionType.Identifier, \"Expected a identifier as first argument in method for second argument\");\r\n        })\r\n    })\r\n\r\n    describe(\"Lambda expression\", () => {\r\n        it(\"should return a method expression\", () => {\r\n            expr = visitor.visitLambda((str: string) => str.indexOf(\"a\"));\r\n\r\n            assert.ok(expr.type == Expr.ExpressionType.Method, \"Expected a MethodExpression\");\r\n            assert.ok((<Expr.IMethodExpression>expr).name == \"indexOf\", \"Expected method name 'indexOf'\");\r\n            assert.ok((<Expr.IMethodExpression>expr).parameters.length == 1, \"Expected one argument\");\r\n            assert.ok((<Expr.IMethodExpression>expr).caller.type == Expr.ExpressionType.Identifier, \"Expected a identifier as caller\");\r\n        })\r\n\r\n        it(\"should return a method expression for nested calls\", () => {\r\n            expr = visitor.visitLambda((str: string) => str.indexOf(\"a\").toString());\r\n\r\n            assert.ok(expr.type == Expr.ExpressionType.Method, \"Expected a MethodExpression\");\r\n            assert.ok((<Expr.IMethodExpression>expr).name == \"toString\", \"Expected method name 'toString'\");\r\n            assert.ok((<Expr.IMethodExpression>expr).parameters.length == 0, \"Expected zero arguments\");\r\n            assert.ok((<Expr.IMethodExpression>expr).caller.type == Expr.ExpressionType.Method, \"Expected a new method as caller\");\r\n\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.IMethodExpression>expr).caller)).name == \"indexOf\", \"Expected method name 'indexOf'\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.IMethodExpression>expr).caller)).parameters.length == 1, \"Expected one argument\");\r\n            assert.ok((<Expr.IMethodExpression>((<Expr.IMethodExpression>expr).caller)).caller.type == Expr.ExpressionType.Identifier, \"Expected a identifier as caller\");\r\n        })\r\n    })\r\n});\r\n"]}