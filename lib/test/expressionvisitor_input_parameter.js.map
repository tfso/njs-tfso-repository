{"version":3,"file":"expressionvisitor_input_parameter.js","sourceRoot":"","sources":["../../src/test/expressionvisitor_input_parameter.ts"],"names":[],"mappings":";;AAAA,iCAAiC;AACjC,gEAAgE;AAEhE,QAAQ,CAAC,oDAAoD,EAAE,GAAG,EAAE;IAChE,IAAI,OAA+B,EAC/B,IAAsB,CAAC;IAE3B,UAAU,CAAC,GAAG,EAAE;QACZ,OAAO,GAAG,IAAI,IAAI,CAAC,iBAAiB,CAAC;IACzC,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,2CAA2C,EAAE,GAAG,EAAE;QACjD,IAAI,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAE7C,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,6BAA6B,CAAC,CAAC;IACtF,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,qDAAqD,EAAE,GAAG,EAAE;QAE3D,IAAI,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,KAAU,EAAE,EAAE,CAAC,KAAK,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QAElE,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,8BAA8B,CAAC,CAAC;QACpF,MAAM,CAAC,EAAE,CAA2B,IAAK,CAAC,QAAQ,IAAI,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,mDAAmD,CAAC,CAAC;QAC3I,MAAM,CAAC,EAAE,CAA2B,IAAK,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,2CAA2C,CAAC,CAAC;QAChI,MAAM,CAAC,EAAE,CAA2B,IAAK,CAAC,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,4CAA4C,CAAC,CAAC;QAClI,MAAM,CAAC,EAAE,CAAoD,IAAK,CAAC,IAAK,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,uEAAuE,CAAC,CAAC;QACjM,MAAM,CAAC,EAAE,CAAoD,IAAK,CAAC,IAAK,CAAC,QAAQ,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,yEAAyE,CAAC,CAAC;QACrM,MAAM,CAAC,EAAE,CAAiF,IAAK,CAAC,IAAK,CAAC,MAAO,CAAC,IAAI,IAAI,OAAO,EAAE,yFAAyF,CAAC,CAAC;QAC1N,MAAM,CAAC,EAAE,CAAiF,IAAK,CAAC,IAAK,CAAC,QAAS,CAAC,IAAI,IAAI,QAAQ,EAAE,4FAA4F,CAAC,CAAC;IACpO,CAAC,CAAC,CAAA;AACN,CAAC,CAAC,CAAA","sourcesContent":["import * as assert from 'assert';\r\nimport * as Expr from './../linq/expressions/expressionvisitor';\r\n\r\ndescribe(\"When using ExpressionVisitor with input parameters\", () => {\r\n    var visitor: Expr.ExpressionVisitor,\r\n        expr: Expr.IExpression;\r\n\r\n    beforeEach(() => {\r\n        visitor = new Expr.ExpressionVisitor;\r\n    })\r\n\r\n    it(\"it should handle a simple binary operator\", () => {\r\n        expr = visitor.visitLambda((table) => 5 + 2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Binary, \"Expected a BinaryExpression\");\r\n    })\r\n\r\n    it(\"it should handle a expression using input parameter\", () => {\r\n\r\n        expr = visitor.visitLambda((table: any) => table.number == 5 + 2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.Equal, \"Expected a logical expression with operator equal\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).left.type == Expr.ExpressionType.Member, \"Expected a member expression at left side\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).right.type == Expr.ExpressionType.Binary, \"Expected a binary expression at right side\");\r\n        assert.ok((<Expr.IMemberExpression>(<Expr.ILogicalExpression>expr).left).object.type == Expr.ExpressionType.Identifier, \"Expected that member object of left side has a member as a identifier\");\r\n        assert.ok((<Expr.IMemberExpression>(<Expr.ILogicalExpression>expr).left).property.type == Expr.ExpressionType.Identifier, \"Expected that member property of left side has a member as a identifier\");\r\n        assert.ok((<Expr.IIdentifierExpression>(<Expr.IMemberExpression>(<Expr.ILogicalExpression>expr).left).object).name == \"table\", \"Expected that member object of left side has a member as a identifier with name 'table'\");\r\n        assert.ok((<Expr.IIdentifierExpression>(<Expr.IMemberExpression>(<Expr.ILogicalExpression>expr).left).property).name == \"number\", \"Expected that member property of left side has a member as a identifier with name 'number'\");\r\n    })\r\n})"]}