{"version":3,"file":"reducervisitor.js","sourceRoot":"","sources":["../../src/test/reducervisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\r\nimport * as Expr from './../linq/expressions/expressionvisitor';\r\nimport { ReducerVisitor } from './../linq/expressions/reducervisitor';\r\n\r\ndescribe(\"When using Reducer for ExpressionVisitor\", () => {\r\n    var reducer: ReducerVisitor,\r\n        vars = { number: 5, array: [8, 7, 6, 5, 4, 3, 2, 1] }\r\n\r\n    beforeEach(() => {\r\n        reducer = new ReducerVisitor();\r\n    })\r\n\r\n    it(\"should evaluate a simple expression with binary operation\", () => {\r\n        let expr = reducer.visitLambda(() => 2 + 3);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == 5, \"Expected a literal of value 5\");\r\n    })\r\n\r\n    it(\"should evaluate a expression with binary operation\", () => {\r\n        let reduced = new ReducerVisitor().visitLambda(() => this.number + 3),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == 8, \"Expected a literal of value 8\");\r\n    })\r\n\r\n    it(\"should evaluate expression\", () => {\r\n        let reduced = reducer.visitLambda(() => this.number == 2 + 3),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'true'\");\r\n    })\r\n\r\n    it(\"should reduce expresion to a minimal expression\", () => {\r\n        let expr = reducer.visitLambda(() => this.unknown == 2 + 3);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a logical expression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.Equal, \"Expected a logical expression with operator equal\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).left.type == Expr.ExpressionType.Member, \"Expected a member expression at left side\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).right.type == Expr.ExpressionType.Literal, \"Expected a literal expression at right side\");\r\n        assert.ok((<Expr.ILiteralExpression>(<Expr.ILogicalExpression>expr).right).value == 5, \"Expected a literal expression at right side of value 5\");\r\n    })\r\n\r\n    it(\"should have a solvable evaluated expression using valid scope\", () => {\r\n        let reduced = reducer.visitLambda(() => this.number == 2 + 3),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal expression\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected the literal value to be true\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using valid scope\", () => {\r\n        let expr = reducer.visitLambda(() => this.number == 2 + 3);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using nullable variable\", () => {\r\n        let reduced = reducer.visitLambda((it, mynullvar) => this.number == mynullvar, null),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal expression\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == false, \"Expected the literal value to be false\");\r\n    })\r\n\r\n\r\n    it(\"should have a unsolvable expression using unknown scope\", () => {\r\n        let expr = reducer.visitLambda(() => this.unknown == 2 + 3);\r\n\r\n        //assert.ok(reducer.isSolvable == false, \"Expected a unsolvable expression\");\r\n    })\r\n\r\n    it(\"should have a unsolvable expression using valid scope that isn't passed in\", () => {\r\n        let expr = reducer.visitLambda(() => this.number == 2 + 3);\r\n\r\n        //assert.ok(reducer.isSolvable == false, \"Expected a unsolvable expression\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using valid scope that is passed into constructor\", () => {\r\n        let reduced = reducer.visitLambda(() => this.number == 2 + 3),\r\n            expr = reducer.evaluate(reduced, { number: 5 });\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'true'\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using valid parameter\", () => {\r\n        let expr = reducer.visitLambda((myobject: any) => myobject.number == 2 + 3);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n    })\r\n\r\n    it(\"should have a solvable evaluated expression using valid parameter\", () => {\r\n        let reduced = reducer.visitLambda((myobject: any) => myobject.number == 2 + 3),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'true'\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using named parameters\", () => {\r\n        let expr = reducer.visitLambda((myobject: any, num: number, letter: string) => myobject.number == 2 + 3 && num == 5 && letter == 'a', 5, 'a');\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a logical expression\");\r\n    })\r\n\r\n    it(\"should have a solvable expression (simple) using named parameters\", () => {\r\n        let expr = reducer.visitLambda((myobject: any, num: number) => myobject.number == num, 5);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a logical expression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).right.type == Expr.ExpressionType.Literal, \"Expected a literal expression at right side\");\r\n        assert.ok((<Expr.ILiteralExpression>(<Expr.ILogicalExpression>expr).right).value == 5, \"Expected a literal expression of value 5\");\r\n\r\n    })\r\n\r\n    it(\"should have a solvable evaluated expression using named parameters\", () => {\r\n        let reduced = reducer.visitLambda((myobject: any, num: number, letter: string) => myobject.number == 2 + 3 && num == 5 && letter == 'a', 5, 'a'),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'true'\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using object parameters\", () => {\r\n        let reduced = reducer.visitLambda((myobject: any, data: any, letter: string) => myobject.subobject.number == 2 + 3 && data.number == 5 && data.letter == 'a' && letter == 'b', { number: 5, letter: 'a' }, 'b'),\r\n            expr = reducer.evaluate(reduced, {\r\n                subobject: {\r\n                    number: 5\r\n                }\r\n            })\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'true'\");\r\n\r\n    })\r\n\r\n    it(\"should not overwrite global/this parameters with input parameters\", () => {\r\n        let reduced = reducer.visitLambda((myobject: any, number: any) => myobject.number == 2 + 3 && number == 6, 6),\r\n            expr = reducer.evaluate(reduced, {\r\n                number: 5\r\n            })\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'true'\");\r\n\r\n    })\r\n\r\n    it(\"should handle conditional expression for success\", () => {\r\n\r\n        let reduced = reducer.visitLambda(() => this.number == 5 ? true : false),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'true'\");\r\n    })\r\n\r\n    it(\"should handle conditional expression for failure\", () => {\r\n\r\n        let reduced = reducer.visitLambda(() => this.number > 5 ? true : false),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == false, \"Expected a literal of value 'false'\");\r\n    })\r\n\r\n    it(\"should handle index expressions for variable with index as literal\", () => {\r\n\r\n        let reduced = reducer.visitLambda(() => this.array[3] == 5),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'false'\");\r\n    })\r\n\r\n    it(\"should handle index expressions for variable with index as expression\", () => {\r\n\r\n        let reduced = reducer.visitLambda(() => this.array[1 + 2] == 5),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'false'\");\r\n    })\r\n\r\n    it(\"should handle index expressions for array literal with index as literal\", () => {\r\n\r\n        let expr = reducer.visitLambda(() => [8, 7, 6, 5, 4][3] == 5)\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'false'\");\r\n    })\r\n\r\n    it(\"should handle index expressions for array literal with index as expression\", () => {\r\n\r\n        let expr = reducer.visitLambda(() => [8, 7, 6, 5, 4][1+2] == 5);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'false'\");\r\n    })\r\n\r\n    it(\"should handle index expressions for array literal of expression with index as expression\", () => {\r\n\r\n        let expr = reducer.visitLambda(() => [4+4, 5+2, 3+3, 2+3, 2+2][1 + 2] == 5);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'false'\");\r\n    })\r\n\r\n    it(\"should handle index expressions for array literal of expression and variables with index as expression\", () => {\r\n\r\n        let reduced = reducer.visitLambda(() => this.array[[8, 7, 6, this.number, 4][1 + 2]] == 3),\r\n            expr = reducer.evaluate(reduced, vars);\r\n\r\n        //assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'false'\");\r\n    })\r\n})\r\n"]}