{"version":3,"file":"expressionvisitor_unary_expression.js","sourceRoot":"","sources":["../../src/test/expressionvisitor_unary_expression.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\r\nimport * as Expr from './../expressions/expressionvisitor';\r\n\r\ndescribe(\"When using ExpressionVisitor for logical Lambda expression\", () => {\r\n    var visitor: Expr.ExpressionVisitor,\r\n        expr: Expr.IExpression;\r\n\r\n    beforeEach(() => {\r\n        visitor = new Expr.ExpressionVisitor;\r\n    })\r\n\r\n    it(\"it should return a unary operation\", () => {\r\n        expr = visitor.visitLambda((a: number) => !a);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Unary, \"Expected a UnaryExpression\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).argument.type == Expr.ExpressionType.Identifier, \"Expected a identifier as argument\");\r\n        assert.ok((<Expr.IIdentifierExpression>(<Expr.IUnaryExpression>expr).argument).name == 'a', \"Expected identifier 'a' as argument\");\r\n    });\r\n\r\n    it(\"it should handle unary operation for negative\", () => {\r\n        expr = visitor.visitLambda((a: number) => -a);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Unary, \"Expected a UnaryExpression\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).operator == Expr.UnaryOperatorType.Negative, \"Expected a unary operation for negative\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).affix == Expr.UnaryAffixType.Prefix, \"Expected unary operation to be prefixed\");\r\n    });\r\n\r\n    it(\"it should handle unary operation for positive\", () => {\r\n        expr = visitor.visitLambda((a: number) => +a);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Unary, \"Expected a UnaryExpression\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).operator == Expr.UnaryOperatorType.Positive, \"Expected a unary operation for positive\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).affix == Expr.UnaryAffixType.Prefix, \"Expected unary operation to be prefixed\");\r\n    });\r\n\r\n    it(\"it should handle unary operation for invert\", () => {\r\n        expr = visitor.visitLambda((a: number) => !a);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Unary, \"Expected a UnaryExpression\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).operator == Expr.UnaryOperatorType.Invert, \"Expected a unary operation for inverting\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).affix == Expr.UnaryAffixType.Prefix, \"Expected unary operation to be prefixed\");\r\n    });\r\n\r\n    it(\"it should handle unary operation for complement\", () => {\r\n        expr = visitor.visitLambda((a: number) => ~a);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Unary, \"Expected a UnaryExpression\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).operator == Expr.UnaryOperatorType.Complement, \"Expected a unary operation for complement\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).affix == Expr.UnaryAffixType.Prefix, \"Expected unary operation to be prefixed\");\r\n    });\r\n\r\n    it(\"it should handle unary operation for prefixed increment\", () => {\r\n        expr = visitor.visitLambda((a: number) => ++a);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Unary, \"Expected a UnaryExpression\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).operator == Expr.UnaryOperatorType.Increment, \"Expected a unary operation for increment\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).affix == Expr.UnaryAffixType.Prefix, \"Expected unary operation to be prefixed\");\r\n    });\r\n\r\n    it(\"it should handle unary operation for postfixed increment\", () => {\r\n        expr = visitor.visitLambda((a: number) => a++);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Unary, \"Expected a UnaryExpression\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).operator == Expr.UnaryOperatorType.Increment, \"Expected a unary operation for increment\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).affix == Expr.UnaryAffixType.Postfix, \"Expected unary operation to be prefixed\");\r\n    });\r\n\r\n    it(\"it should handle unary operation for prefixed decrement\", () => {\r\n        expr = visitor.visitLambda((a: number) => --a);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Unary, \"Expected a UnaryExpression\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).operator == Expr.UnaryOperatorType.Decrement, \"Expected a unary operation for decrement\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).affix == Expr.UnaryAffixType.Prefix, \"Expected unary operation to be prefixed\");\r\n    });\r\n\r\n    it(\"it should handle unary operation for postfixed decrement\", () => {\r\n        expr = visitor.visitLambda((a: number) => a--);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Unary, \"Expected a UnaryExpression\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).operator == Expr.UnaryOperatorType.Decrement, \"Expected a unary operation for decrement\");\r\n        assert.ok((<Expr.IUnaryExpression>expr).affix == Expr.UnaryAffixType.Postfix, \"Expected unary operation to be prefixed\");\r\n    });\r\n\r\n    it(\"it should handle unary operation increment in binary operation\", () => {\r\n        expr = visitor.visitLambda((a: number) => 5 - a++);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Binary, \"Expected a BinaryExpression\");\r\n        assert.ok((<Expr.IBinaryExpression>expr).operator == Expr.BinaryOperatorType.Subtraction, \"Expected binary operation for subtraction\");\r\n        assert.ok((<Expr.IBinaryExpression>expr).left.type == Expr.ExpressionType.Literal, \"Expected a literal expression at left side\");\r\n        assert.ok((<Expr.IBinaryExpression>expr).right.type == Expr.ExpressionType.Unary, \"Expected a unary expression at right side\");\r\n        assert.ok((<Expr.IUnaryExpression>(<Expr.IBinaryExpression>expr).right).operator == Expr.UnaryOperatorType.Increment, \"Expected a unary operation to be increment\");\r\n        assert.ok((<Expr.IUnaryExpression>(<Expr.IBinaryExpression>expr).right).argument.type == Expr.ExpressionType.Identifier, \"Expected a unary operation to have an argument as Identifier\");\r\n    });\r\n\r\n    it(\"it should handle unary operation decrement in binary operation\", () => {\r\n        expr = visitor.visitLambda((a: number) => 5 - a--);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Binary, \"Expected a BinaryExpression\");\r\n        assert.ok((<Expr.IBinaryExpression>expr).operator == Expr.BinaryOperatorType.Subtraction, \"Expected binary operation for subtraction\");\r\n        assert.ok((<Expr.IBinaryExpression>expr).left.type == Expr.ExpressionType.Literal, \"Expected a literal expression at left side\");\r\n        assert.ok((<Expr.IBinaryExpression>expr).right.type == Expr.ExpressionType.Unary, \"Expected a unary expression at right side\");\r\n        assert.ok((<Expr.IUnaryExpression>(<Expr.IBinaryExpression>expr).right).operator == Expr.UnaryOperatorType.Decrement, \"Expected a unary operation to be decrement\");\r\n        assert.ok((<Expr.IUnaryExpression>(<Expr.IBinaryExpression>expr).right).argument.type == Expr.ExpressionType.Identifier, \"Expected a unary operation to have an argument as Identifier\");\r\n    });\r\n});\r\n"]}