{"version":3,"file":"templateliteralvisitor.js","sourceRoot":"","sources":["../../src/test/templateliteralvisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\nimport * as Expr from './../linq/expressions/expressionvisitor';\nimport { TemplateLiteralVisitor } from './../linq/expressions/templateliteralvisitor';\n\ndescribe(\"When using TemplateLiteral for ExpressionVisitor\", () => {\n    var template: TemplateLiteralVisitor,\n        vars = { number: 5, array: [8, 7, 6, 5, 4, 3, 2, 1] }\n\n    beforeEach(() => {\n        template = new TemplateLiteralVisitor((value) => {\n            switch (typeof value)\n            {\n                case 'object':\n                    if ((<Object>value).hasOwnProperty('key'))\n                        return '<a href=\"#' + value['key'] + '\">' + value['value'] + '</a>';\n                    else\n                        return '<a href=\"#' + value['value'] + '\">' + value['value'] + '</a>';\n                        \n                default:\n                    return value;\n            }\n        });\n    })\n\n    var number = 5;\n\n    it(\"should handle a simple template literal\", () => {\n        let reduced = template.visitLambda(() => `My number is ${this.number} and my next is ${this.number + 1}`),\n            expr = template.evaluate(reduced, vars);\n\n        //assert.ok(template.isSolvable == true, \"Expected a solvable expression\");\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\n        assert.ok((<Expr.ILiteralExpression>expr).value == 'My number is 5 and my next is 6');\n    })\n\n    it(\"should handle objects as expression\", () => {\n\n        let reduced = template.visitLambda(() => `My number is ${{ key: 0 + 1, value: this.number + 1 }} and my next is ${this.number + 1}`)\n            \n        assert.equal(reduced.type, Expr.ExpressionType.TemplateLiteral);\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements.length, 4);\n\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements[1].type, Expr.ExpressionType.Object);\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements[3].type, Expr.ExpressionType.Binary);\n\n        let expr = template.evaluate(reduced, vars);\n\n        assert.ok((<Expr.ILiteralExpression>expr).value == 'My number is <a href=\"#1\">6</a> and my next is 6');\n    })\n\n    it(\"should reduce it as much as possible\", () => {\n        let reduced = template.visitLambda(() => `My number is ${this.number} and my next is ${5 + 1}`)\n            \n        assert.equal(reduced.type, Expr.ExpressionType.TemplateLiteral);\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements.length, 4);\n\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements[3].type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.ILiteralExpression>(<Expr.ITemplateLiteralExpression>reduced).elements[3]).value, '6');\n\n        let compiled = template.evaluate(reduced, vars);\n        assert.ok((<Expr.ILiteralExpression>compiled).value == 'My number is 5 and my next is 6');\n    })\n\n    it(\"should handle the signature of tagged template literals\", () => {\n        let expr = template.visitLambda(() => `My number is ${5} and my next is ${5 + 1}`);\n        let es6literal = tag `My number is ${5} and my next is ${5 + 1}`\n\n        assert.equal(expr.type, Expr.ExpressionType.TemplateLiteral);\n        assert.equal((<Expr.ITemplateLiteralExpression>expr).elements.length, 4);\n\n        assert.equal((<Expr.ITemplateLiteralExpression>expr).literals.length, 2);\n        assert.equal((<Expr.ITemplateLiteralExpression>expr).expressions.length, 2);\n\n        for(let literal of (<Expr.ITemplateLiteralExpression>expr).literals)\n            assert.equal(literal.value, es6literal.literals.shift());\n\n        for(let expression of (<Expr.ITemplateLiteralExpression>expr).expressions)\n            assert.equal((<Expr.ILiteralExpression>expression).value, es6literal.expressions.shift());\n    })\n\n    it(\"should handle template literal expression as string\", () => {\n        let expr = template.visitLambdaExpression('`My number is ${5} and my next is ${5 + 1}`');\n\n        assert.equal(expr.type, Expr.ExpressionType.TemplateLiteral);\n        assert.equal((<Expr.ITemplateLiteralExpression>expr).elements.length, 4);\n\n        assert.equal((<Expr.ITemplateLiteralExpression>expr).literals.length, 2);\n        assert.equal((<Expr.ITemplateLiteralExpression>expr).expressions.length, 2);\n    })\n\n    it(\"should handle a complex template literal\", () => {\n        let reduced = template.visitLambda(() => `My answer is ${ {'Yes': 1, 'No': 0}[this.answer] == 1 ? 'Yeah' : 'Nope' } all ${5+2} days`);\n\n        let firstAnswer = template.evaluate(reduced, { answer: 'Yes'});\n        assert.ok((<Expr.ILiteralExpression>firstAnswer).value == 'My answer is Yeah all 7 days');\n\n        let secondAnswer = template.evaluate(reduced, { answer: 'No'});\n        assert.ok((<Expr.ILiteralExpression>secondAnswer).value == 'My answer is Nope all 7 days');\n    })\n\n    it(\"should handle different escaping of placeholders etc\", () => {\n        assert.equal((<Expr.ILiteralExpression>template.evaluate(template.visitLambda(() => `My answer is \\${1} for now`), {})).value, 'My answer is ${1} for now');\n        assert.equal((<Expr.ILiteralExpression>template.evaluate(template.visitLambda(() => `My answer is $\\{2} for now`), {})).value, 'My answer is ${2} for now');\n        assert.equal((<Expr.ILiteralExpression>template.evaluate(template.visitLambda(() => `My answer is \\$\\{3} for now`), {})).value, 'My answer is ${3} for now');\n        assert.equal((<Expr.ILiteralExpression>template.evaluate(template.visitLambda(() => `My value is $4`), {})).value, 'My value is $4');\n        assert.equal((<Expr.ILiteralExpression>template.evaluate(template.visitLambda(() => `My value is \\$5`), {})).value, 'My value is \\\\$5');\n    })\n})\n\nfunction tag(parts: TemplateStringsArray, ...expressions: Array<any>) {\n    return {\n        literals: Array.from(parts),\n        expressions: Array.from(expressions)\n    }\n}"]}