{"version":3,"file":"expression.js","sourceRoot":"","sources":["../../../src/linq/expressions/expression.ts"],"names":[],"mappings":";;AACA,qDAAkD;AA2F5B,yBA3Fb,+BAAc,CA2Fa;AAzEpC,MAAsB,UAAU;IAG5B,YAAY,IAAoB;QAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACtB,CAAC;IAED,IAAI,IAAI;QACJ,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAED,IAAI,IAAI,CAAC,KAAK;QACV,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,CAAC;IAEM,MAAM,CAA+B,OAAU;QAClD,IAAI,UAAuB,CAAC;QAE5B,wDAAwD;QACxD,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEzB,QAAQ,IAAI,CAAC,IAAI,EAAE;YACf,KAAK,+BAAc,CAAC,OAAO;gBACvB,UAAU,GAAG,OAAO,CAAC,YAAY,CAA6B,IAAI,CAAC,CAAC;gBAAC,MAAM;YAE/E,KAAK,+BAAc,CAAC,QAAQ;gBACxB,UAAU,GAAG,OAAO,CAAC,aAAa,CAA8B,IAAI,CAAC,CAAC;gBAAC,MAAM;YAEjF,KAAK,+BAAc,CAAC,UAAU;gBAC1B,UAAU,GAAG,OAAO,CAAC,eAAe,CAAgC,IAAI,CAAC,CAAC;gBAAC,MAAM;YAErF,KAAK,+BAAc,CAAC,MAAM;gBACtB,UAAU,GAAG,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;gBAAC,MAAM;YAE7E,KAAK,+BAAc,CAAC,MAAM;gBACtB,UAAU,GAAG,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;gBAAC,MAAM;YAE7E,KAAK,+BAAc,CAAC,KAAK;gBACrB,UAAU,GAAG,OAAO,CAAC,UAAU,CAA2B,IAAI,CAAC,CAAC;gBAAC,MAAM;YAE3E,KAAK,+BAAc,CAAC,MAAM;gBACtB,UAAU,GAAG,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;gBAAC,MAAM;YAE7E,KAAK,+BAAc,CAAC,OAAO;gBACvB,UAAU,GAAG,OAAO,CAAC,YAAY,CAA6B,IAAI,CAAC,CAAC;gBAAC,MAAM;YAE/E,KAAK,+BAAc,CAAC,WAAW;gBAC3B,UAAU,GAAG,OAAO,CAAC,gBAAgB,CAAiC,IAAI,CAAC,CAAC;gBAAC,MAAM;YAEvF,KAAK,+BAAc,CAAC,KAAK;gBACrB,UAAU,GAAG,OAAO,CAAC,UAAU,CAA2B,IAAI,CAAC,CAAC;gBAAC,MAAM;YAE3E,KAAK,+BAAc,CAAC,KAAK;gBACrB,UAAU,GAAG,OAAO,CAAC,UAAU,CAA2B,IAAI,CAAC,CAAC;gBAAC,MAAM;YAE3E,KAAK,+BAAc,CAAC,eAAe;gBAC/B,UAAU,GAAG,OAAO,CAAC,oBAAoB,CAAqC,IAAI,CAAC,CAAC;gBAAC,MAAM;YAE/F,KAAK,+BAAc,CAAC,MAAM;gBACtB,UAAU,GAAG,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;gBAAC,MAAM;SAChF;QAED,uBAAuB;QACvB,OAAO,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;QAEpB,sCAAsC;QACtC,OAAO,UAAU,CAAC;IACtB,CAAC;CAIJ;AAvED,gCAuEC","sourcesContent":["import { IExpression } from './interfaces/iexpression';\r\nimport { ExpressionType } from './expressiontype';\r\n\r\nimport { ILiteralExpression } from './interfaces/iliteralexpression';\r\nimport { ICompoundExpression } from './interfaces/icompoundexpression';\r\nimport { IIdentifierExpression } from './interfaces/iidentifierexpression';\r\nimport { IMemberExpression } from './interfaces/imemberexpression';\r\nimport { IMethodExpression } from './interfaces/imethodexpression';\r\nimport { IUnaryExpression } from './interfaces/iunaryexpression';\r\nimport { IBinaryExpression } from './interfaces/ibinaryexpression';\r\nimport { ILogicalExpression } from './interfaces/ilogicalexpression';\r\nimport { IConditionalExpression } from './interfaces/iconditionalexpression';\r\nimport { IArrayExpression } from './interfaces/iarrayexpression';\r\nimport { IIndexExpression } from './interfaces/iindexexpression';\r\nimport { ITemplateLiteralExpression } from './interfaces/itemplateliteralexpression';\r\nimport { IObjectExpression } from './interfaces/iobjectexpression';\r\n\r\nimport { IExpressionVisitor } from './interfaces/iexpressionvisitor';\r\n\r\nexport abstract class Expression implements IExpression {\r\n    private _type: ExpressionType;\r\n\r\n    constructor(type: ExpressionType) { //(predicate: (it: Object) => boolean, parameters?: any) {\r\n        this._type = type;\r\n    }\r\n\r\n    get type() {\r\n        return this._type;\r\n    }\r\n\r\n    set type(value) {\r\n        this._type = value;\r\n    }\r\n\r\n    public accept<T extends IExpressionVisitor>(visitor: T) {\r\n        let expression: IExpression;\r\n\r\n        // add this as parent to stack for next acceptance/visit\r\n        visitor.stack.push(this);\r\n\r\n        switch (this.type) {\r\n            case ExpressionType.Literal:\r\n                expression = visitor.visitLiteral(<ILiteralExpression><Object>this); break;\r\n\r\n            case ExpressionType.Compound:\r\n                expression = visitor.visitCompound(<ICompoundExpression><Object>this); break;\r\n\r\n            case ExpressionType.Identifier:\r\n                expression = visitor.visitIdentifier(<IIdentifierExpression><Object>this); break;\r\n\r\n            case ExpressionType.Member:\r\n                expression = visitor.visitMember(<IMemberExpression><Object>this); break;\r\n\r\n            case ExpressionType.Method:\r\n                expression = visitor.visitMethod(<IMethodExpression><Object>this); break;\r\n\r\n            case ExpressionType.Unary:\r\n                expression = visitor.visitUnary(<IUnaryExpression><Object>this); break;\r\n\r\n            case ExpressionType.Binary:\r\n                expression = visitor.visitBinary(<IBinaryExpression><Object>this); break;\r\n\r\n            case ExpressionType.Logical:\r\n                expression = visitor.visitLogical(<ILogicalExpression><Object>this); break;\r\n\r\n            case ExpressionType.Conditional:\r\n                expression = visitor.visitConditional(<IConditionalExpression><Object>this); break;\r\n\r\n            case ExpressionType.Array:\r\n                expression = visitor.visitArray(<IArrayExpression><Object>this); break;\r\n\r\n            case ExpressionType.Index:\r\n                expression = visitor.visitIndex(<IIndexExpression><Object>this); break;\r\n\r\n            case ExpressionType.TemplateLiteral:\r\n                expression = visitor.visitTemplateLiteral(<ITemplateLiteralExpression><Object>this); break;\r\n\r\n            case ExpressionType.Object:\r\n                expression = visitor.visitObject(<IObjectExpression><Object>this); break;\r\n        }\r\n\r\n        // remove it from stack\r\n        visitor.stack.pop();\r\n\r\n        // return the newly visited expression\r\n        return expression;\r\n    }\r\n\r\n    public abstract equal(expression: IExpression): boolean\r\n    public abstract toString(): string\r\n}\r\n\r\nexport { IExpression, ExpressionType }"]}