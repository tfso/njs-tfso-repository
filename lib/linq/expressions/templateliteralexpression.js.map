{"version":3,"file":"templateliteralexpression.js","sourceRoot":"","sources":["../../../src/linq/expressions/templateliteralexpression.ts"],"names":[],"mappings":"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","sourcesContent":["import { ITemplateLiteralExpression } from './interfaces/itemplateliteralexpression';\n\nimport { IExpression, Expression, ExpressionType } from './expression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\n\nexport class TemplateLiteralExpression extends Expression implements ITemplateLiteralExpression {\n    private _elements: Array<IExpression> = [];\n\n    private indexerLiterals: Array<number> = []\n    private indexerExpressions: Array<number> = [];\n    \n    /**\n     * Literals and Expressions comes always in pairs, so first literal and last expression may be empty\n     * @param literals \n     * @param expressions \n     */\n    constructor(literals: Array<ILiteralExpression> = [], expressions: Array<IExpression> = []) {\n        super(ExpressionType.TemplateLiteral);\n\n        this.combine(literals, expressions);\n    }\n\n    public equal(expression: ITemplateLiteralExpression): boolean {\n        if (this.type == expression.type && this.elements.length == expression.elements.length)\n        {\n            for (let i = 0; i < this.elements.length; i++)\n            {\n                if (this.elements[i].equal(expression.elements[i]) == false)\n                    return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public get elements() {\n        return this._elements;\n    }\n\n    public set elements(value) {\n        this._elements = value;\n    }\n\n    public get literals(): Array<ILiteralExpression> {\n        return this.elements\n            .filter((expr, idx) => this.indexerLiterals.indexOf(idx) >= 0)\n            .map(expr => <ILiteralExpression>expr);\n    }\n\n    public get expressions(): Array<IExpression> {\n        return this.elements\n            .filter((expr, idx) => this.indexerExpressions.indexOf(idx) >= 0)\n    }\n\n    public toString() {\n        return `\\`${(this.elements || [])\n            .map((element, idx) => {\n                let value = element.toString();\n\n                if( this.indexerLiterals.indexOf(idx) >= 0 )\n                    return value.slice(1, value.length - 1);\n                \n                return `\\$\\{${element.toString()}\\}`\n            })\n            .join('')\n        }\\``\n    }\n\n    private combine(literals: Array<IExpression> = [], expressions: Array<IExpression> = []) {\n        for(let i = 0; i < literals.length; i++)\n        {\n            this.indexerLiterals.push( this._elements.push(literals[i]) - 1 );\n            \n            if(i < expressions.length)\n                this.indexerExpressions.push( this._elements.push(expressions[i]) - 1);\n        }\n    }\n}\n\nexport { ITemplateLiteralExpression }"]}