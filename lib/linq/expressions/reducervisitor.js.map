{"version":3,"file":"reducervisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/reducervisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { \r\n    IExpression, Expression, ExpressionType,\r\n    ILiteralExpression, LiteralExpression,\r\n    ICompoundExpression,\r\n    IIdentifierExpression, IdentifierExpression,\r\n    IMemberExpression, MemberExpression,\r\n    IMethodExpression, MethodExpression,\r\n    IUnaryExpression, UnaryExpression, UnaryOperatorType, UnaryAffixType,\r\n    IBinaryExpression, BinaryExpression, BinaryOperatorType,\r\n    ILogicalExpression, LogicalExpression, LogicalOperatorType,\r\n    IConditionalExpression, ConditionalExpression,\r\n    IArrayExpression, ArrayExpression,\r\n    IIndexExpression, IndexExpression,\r\n    ITemplateLiteralExpression, TemplateLiteralExpression,\r\n    IObjectExpression, ObjectExpression, IObjectProperty \r\n} from './expressionvisitor';\r\n\r\nimport { LambdaExpression } from './lambdaexpression';\r\nimport { ExpressionVisitor } from './expressionvisitor';\r\n\r\nexport class ReducerVisitor extends ExpressionVisitor {\r\n    private _parentExpressionStack: Array<IExpression> = [];\r\n    private _it: string = null;\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    public get it(): string {\r\n        return this._it;\r\n    }\r\n\r\n    public visitLambda(predicate: (it: Object, ...param: Array<any>) => any, ...param: Array<any>): IExpression {\r\n        //this._isSolvable = true; // reset it as checks for solvability is done for each visit\r\n        this._it = null; // do not involve \"this\" at the moment, since evalute is using \"ReducerVisitor.it\" to find out the named \"this\" scope.\r\n\r\n        let expr = super.visitLambda(predicate),\r\n            vars = null;\r\n\r\n        if (param.length > 0)\r\n        {\r\n            if (this._lambdaExpression && this._lambdaExpression.parameters.length > 0)\r\n            {\r\n                vars = this._lambdaExpression.parameters.reduce((res, val, index) => {\r\n                    if (index > 0 && index <= param.length)\r\n                        res[val] = param[index - 1]\r\n\r\n                    return res;\r\n                }, {});\r\n            }\r\n        }\r\n\r\n        expr = this.evaluate.call(this, expr, vars);\r\n\r\n        this._it = this._lambdaExpression != null && this._lambdaExpression.parameters.length > 0 ? this._lambdaExpression.parameters[0] : null;\r\n\r\n        return expr;\r\n    }\r\n\r\n    public visitLiteral(expression: ILiteralExpression): IExpression {\r\n        return this.evaluate(expression);\r\n    }\r\n\r\n    public visitMethod(expression: IMethodExpression): IExpression {\r\n        let expr: IMethodExpression,\r\n            value: any;\r\n\r\n        expr = new MethodExpression(expression.name, expression.parameters.map((arg) => arg.accept(this)), expression.caller);\r\n\r\n        return expr;\r\n    }\r\n\r\n    public visitBinary(expression: IBinaryExpression): IExpression {\r\n        let left = expression.left,\r\n            right = expression.right; \r\n\r\n        if (left.type == ExpressionType.Literal && right.type == ExpressionType.Literal)\r\n        {\r\n            let leftValue = (<LiteralExpression>left).value,\r\n                rightValue = (<LiteralExpression>right).value;\r\n\r\n            switch (expression.operator) {\r\n                case BinaryOperatorType.Addition:\r\n                    return new LiteralExpression(leftValue + rightValue);\r\n\r\n                case BinaryOperatorType.Subtraction:\r\n                    return new LiteralExpression(leftValue - rightValue);\r\n\r\n                case BinaryOperatorType.Multiplication:\r\n                    return new LiteralExpression(leftValue * rightValue);\r\n\r\n                case BinaryOperatorType.Division:\r\n                    return new LiteralExpression(leftValue / rightValue);\r\n\r\n                case BinaryOperatorType.Modulus:\r\n                    return new LiteralExpression(leftValue % rightValue);\r\n\r\n                case BinaryOperatorType.And:\r\n                    return new LiteralExpression(leftValue & rightValue);\r\n\r\n                case BinaryOperatorType.Or:\r\n                    return new LiteralExpression(leftValue | rightValue);\r\n\r\n                case BinaryOperatorType.ExclusiveOr:\r\n                    return new LiteralExpression(leftValue ^ rightValue);\r\n\r\n                case BinaryOperatorType.LeftShift:\r\n                    return new LiteralExpression(leftValue << rightValue);\r\n\r\n                case BinaryOperatorType.RightShift:\r\n                    return new LiteralExpression(leftValue >> rightValue);\r\n            }\r\n        }\r\n\r\n        return new BinaryExpression(expression.operator, left.accept(this), right.accept(this));\r\n    }\r\n\r\n    public visitConditional(expression: IConditionalExpression): IExpression {\r\n        let condition = expression.condition.accept(this);\r\n\r\n        if (condition.type == ExpressionType.Literal)\r\n        {\r\n            if ((<LiteralExpression>condition).value === true)\r\n                return expression.success.accept(this);\r\n            else\r\n                return expression.failure.accept(this);\r\n        }\r\n\r\n        return new ConditionalExpression(condition, expression.success.accept(this), expression.failure.accept(this));\r\n    }\r\n\r\n    public visitLogical(expression: ILogicalExpression): IExpression {\r\n        let left = expression.left.accept(this),\r\n            right = expression.right.accept(this);\r\n\r\n        if (left.type == ExpressionType.Literal && right.type == ExpressionType.Literal) {\r\n            let leftValue = (<LiteralExpression>left).value,\r\n                rightValue = (<LiteralExpression>right).value;\r\n\r\n            switch (expression.operator) {\r\n                case LogicalOperatorType.Equal:\r\n                    return new LiteralExpression(leftValue == rightValue);\r\n                case LogicalOperatorType.NotEqual:\r\n                    return new LiteralExpression(leftValue != rightValue);\r\n                case LogicalOperatorType.And:\r\n                    return new LiteralExpression(leftValue && rightValue);\r\n                case LogicalOperatorType.Or:\r\n                    return new LiteralExpression(leftValue || rightValue);\r\n                case LogicalOperatorType.Greater:\r\n                    return new LiteralExpression(leftValue > rightValue);\r\n                case LogicalOperatorType.GreaterOrEqual:\r\n                    return new LiteralExpression(leftValue >= rightValue);\r\n                case LogicalOperatorType.Lesser:\r\n                    return new LiteralExpression(leftValue < rightValue);\r\n                case LogicalOperatorType.LesserOrEqual:\r\n                    return new LiteralExpression(leftValue <= rightValue);\r\n            }\r\n        }\r\n\r\n        switch (expression.operator) {\r\n            case LogicalOperatorType.And:\r\n                if (left.type == ExpressionType.Literal && (<LiteralExpression>left).value === true) return right;\r\n                if (right.type == ExpressionType.Literal && (<LiteralExpression>right).value === true) return left;\r\n\r\n                break;\r\n\r\n            case LogicalOperatorType.Or:\r\n                if (left.type == ExpressionType.Literal && (<LiteralExpression>left).value === true) return left;\r\n                if (right.type == ExpressionType.Literal && (<LiteralExpression>right).value === true) return right;\r\n\r\n                break;\r\n        }\r\n\r\n        return new LogicalExpression(expression.operator, left, right);\r\n    }\r\n\r\n    public evaluate(expression: IExpression, it?: Object): IExpression \r\n    public evaluate(expression: IExpression, it: Object = null): IExpression {\r\n        if (expression == null)\r\n            return null;\r\n\r\n        var value: any = null;\r\n            \r\n\r\n        switch (expression.type) {\r\n            case ExpressionType.Literal: \r\n                break;\r\n\r\n            case ExpressionType.Identifier: {\r\n                var identifier = (<IIdentifierExpression>expression);\r\n\r\n                if (it != null)\r\n                {\r\n                    // this object\r\n                    if (it.hasOwnProperty(identifier.name) && (value = it[identifier.name]) !== undefined)\r\n                    {\r\n                        if (value == null)\r\n                            return new LiteralExpression(null);\r\n\r\n                        switch (typeof value)\r\n                        {\r\n                            case 'string':\r\n                            case 'number':\r\n                            case 'boolean':\r\n                                break;\r\n                        \r\n                            case 'object':\r\n                                if (value.getTime && value.getTime() >= 0)\r\n                                    break;\r\n\r\n                                if (Array.isArray(value) == true)\r\n                                    break;\r\n\r\n                            // fall through\r\n\r\n                            default:\r\n                                value = null;\r\n                        }\r\n\r\n                        return new LiteralExpression(value);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case ExpressionType.Array:\r\n                return new ArrayExpression((<IArrayExpression>expression).elements.map(v => this.evaluate(v, it)));\r\n\r\n            case ExpressionType.Object:\r\n                return new ObjectExpression((<IObjectExpression>expression).properties.map(el => <IObjectProperty>{ key: this.evaluate(el.key, it), value: this.evaluate(el.value, it) }));\r\n\r\n            case ExpressionType.Index: {\r\n                let object = this.evaluate((<IIndexExpression>expression).object, it),\r\n                    index = this.evaluate((<IIndexExpression>expression).index, it);\r\n\r\n                if (index.type == ExpressionType.Literal)\r\n                    switch (object.type)\r\n                    {\r\n                        case ExpressionType.Object: \r\n                            let property = (<IObjectExpression>object).properties.find(prop => {\r\n                                switch(prop.key.type) {\r\n                                    case ExpressionType.Identifier:\r\n                                        if( (<IIdentifierExpression>prop.key).name == (<ILiteralExpression>index).value)\r\n                                            return true;\r\n                                        break;\r\n\r\n                                    case ExpressionType.Literal:\r\n                                        if((<ILiteralExpression>prop.key).value == (<ILiteralExpression>index).value)\r\n                                            return true;\r\n                                        break;\r\n                                }\r\n\r\n                                return false;\r\n                            })\r\n                            return property ? this.evaluate(property.value) : new LiteralExpression(null);\r\n\r\n                        case ExpressionType.Array:\r\n                            return Array.from((<IArrayExpression>object).elements)[(<ILiteralExpression>index).value];\r\n                            \r\n                        case ExpressionType.Literal:\r\n                            if(typeof (<ILiteralExpression>object).value == 'object') {\r\n                                if(Array.isArray((<ILiteralExpression>object).value)) {\r\n                                    return new LiteralExpression(Array.from((<ILiteralExpression>object).value)[(<ILiteralExpression>index).value]);\r\n                                }\r\n                                \r\n                                let descriptor: PropertyDescriptor;\r\n                                if( descriptor = Object.getOwnPropertyDescriptor( (<ILiteralExpression>object).value, (<ILiteralExpression>index).value))\r\n                                    return new LiteralExpression(descriptor.value);\r\n                            }\r\n                            \r\n                            return new LiteralExpression(null);                            \r\n                    }\r\n\r\n                break;\r\n            }\r\n\r\n            case ExpressionType.Member: {\r\n                let object = (<IMemberExpression>expression).object,\r\n                    property = (<IMemberExpression>expression).property;\r\n\r\n                if (it != null)\r\n                {\r\n                    if (object.type == ExpressionType.Identifier)\r\n                    {\r\n                        if ((<IIdentifierExpression>object).name == 'this' || (<IIdentifierExpression>object).name == this.it)\r\n                        {\r\n                            value = this.evaluate(property, it);\r\n                            if (property.equal(value) == false)\r\n                                return value;\r\n                        }\r\n                        else\r\n                        {\r\n                            let descriptor = Object.getOwnPropertyDescriptor(it, (<IIdentifierExpression>object).name);\r\n                            if (descriptor && typeof descriptor.value == 'object')\r\n                            {\r\n                                value = this.evaluate(property, descriptor.value);\r\n                                if (property.equal(value) == false)\r\n                                    return value;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case ExpressionType.Conditional:\r\n                return this.visit(new ConditionalExpression(this.evaluate((<IConditionalExpression>expression).condition, it), this.evaluate((<IConditionalExpression>expression).success, it), this.evaluate((<IConditionalExpression>expression).failure, it)));\r\n\r\n            case ExpressionType.Logical:\r\n                return this.visit(new LogicalExpression((<ILogicalExpression>expression).operator, this.evaluate((<ILogicalExpression>expression).left, it), this.evaluate((<ILogicalExpression>expression).right, it)));\r\n\r\n            case ExpressionType.Binary:\r\n                return this.visit(new BinaryExpression((<IBinaryExpression>expression).operator, this.evaluate((<IBinaryExpression>expression).left, it), this.evaluate((<IBinaryExpression>expression).right, it)));\r\n\r\n            case ExpressionType.Method:\r\n                return this.visit(new MethodExpression((<IMethodExpression>expression).name, (<IMethodExpression>expression).parameters.map(p => this.evaluate(p, it)), this.evaluate((<IMethodExpression>expression).caller, it)));\r\n            \r\n            default:\r\n                let o = <IExpression>Object.create(Object.getPrototypeOf(expression), Object.getOwnPropertyNames(expression).reduce((prev, cur) => {\r\n                    let prop = Object.getOwnPropertyDescriptor(expression, cur);\r\n\r\n                    if (prop.value instanceof Expression)\r\n                        prop.value = this.evaluate(prop.value, it);\r\n                    else if (prop.value instanceof Array)\r\n                        prop.value = prop.value.map(a => a instanceof Expression ? this.evaluate(a, it) : a);\r\n\r\n                    prev[cur] = prop;\r\n\r\n                    return prev;\r\n                }, {}));\r\n\r\n                return this.visit(o);\r\n        }\r\n\r\n        return expression;\r\n    }\r\n\r\n    public static evaluate(expression: IExpression, it: Object = null): any {\r\n        let reducer = new ReducerVisitor(),\r\n            result = reducer.evaluate(expression, it);\r\n\r\n        return result.type == ExpressionType.Literal ? (<ILiteralExpression>result).value : undefined;\r\n    }\r\n\r\n    //private getInputParameters(): {} {\r\n    //    if (this._lambdaExpression && this._lambdaExpression.parameters.length > 0)\r\n    //        return this._lambdaExpression.parameters.reduce((res, val, index) => {\r\n    //            if (index > 0 && index <= this._params.length)\r\n    //                res[val] = this._params[index - 1]\r\n\r\n    //            return res;\r\n    //        }, {})\r\n\r\n    //    return {}\r\n    //}\r\n}\r\n\r\n"]}