{"version":3,"file":"remapvisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/remapvisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\nimport { IMemberExpression, MemberExpression } from './memberexpression';\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './logicalexpression';\nimport { IMethodExpression } from './methodexpression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\n\nimport { ExpressionVisitor } from './expressionvisitor';\n\nexport class RemapVisitor extends ExpressionVisitor {\n    constructor(private remapKey: (name: string) => string, private remapValue: (name: string, value: any) => any) {\n        super();\n\n        if (typeof this.remapKey != 'function')\n            this.remapKey = null;\n\n        if (typeof this.remapValue != 'function')\n            this.remapValue = null;\n    }\n\n    public visit(expression: IExpression): IExpression {\n        return expression.accept(this);\n    }\n\n    public visitLiteral(expression: ILiteralExpression): IExpression {\n        let parent = this.stack.peek(),\n            property: IExpression,\n            value: any;\n        \n        if (this.remapValue && (property = this.findIdentifier(parent)) && (value = this.remapValue(this.flattenMember(property), expression.value)) !== undefined)\n            return new LiteralExpression(value);\n\n        return new LiteralExpression(expression.value)\n    }\n\n    public visitIdentifier(expression: IIdentifierExpression): IExpression {\n        let parent = this.stack.peek(),\n            name: string;\n\n        if (this.remapKey && parent.type != ExpressionType.Member) {\n            if ((name = this.remapKey(expression.name)) != null)\n                return new IdentifierExpression(name);\n        }\n\n        return new IdentifierExpression(expression.name);\n    }\n\n    public visitMember(expression: IMemberExpression): IExpression {       \n        let path: string;\n   \n        if (this.remapKey && (path = this.remapKey(this.flattenMember(expression))) != null)\n            return this.unflattenMember(path);\n\n        return new MemberExpression(expression.object.accept(this), expression.property.accept(this));\n    }\n\n    private findIdentifier(expression: IExpression): IExpression {\n        let member: any;\n\n        switch (expression.type) {\n            case ExpressionType.Logical:\n                if ((member = this.findIdentifier((<ILogicalExpression>expression).left)) != null)\n                    return member;\n\n                if ((member = this.findIdentifier((<ILogicalExpression>expression).right)) != null)\n                    return member;\n\n                break;\n\n            case ExpressionType.Identifier:\n                return expression;\n\n            case ExpressionType.Member:\n                return expression;\n\n            case ExpressionType.Method:\n                if ((<IMethodExpression>expression).caller != null && (member = this.findIdentifier((<IMethodExpression>expression).caller)) != null)\n                    return member;\n\n                if ((<IMethodExpression>expression).parameters.length >= 1 && (member = this.findIdentifier((<IMethodExpression>expression).parameters[0])) != null)\n                    return member;\n\n                break;\n        }\n\n        return null;\n    }\n\n    private flattenMember(expression: IExpression): string {\n        switch (expression.type) {\n            case ExpressionType.Member:\n                let prop = this.flattenMember((<IMemberExpression>expression).property);\n\n                return this.flattenMember((<IMemberExpression>expression).object) + (prop.length > 0 ? '.' + prop : '');\n                \n            case ExpressionType.Identifier:\n                return (<IIdentifierExpression>expression).name;\n\n            default:\n                return \"\";\n        }\n    }\n\n    private unflattenMember(path: string, idx: number = 0): IExpression {\n        let parts = path.split('.');\n\n        if (idx + 1 >= parts.length)\n            return new IdentifierExpression(parts[idx]);\n\n        return new MemberExpression(new IdentifierExpression(parts[idx]), this.unflattenMember(path, idx + 1));\n    }\n\n}\n"]}