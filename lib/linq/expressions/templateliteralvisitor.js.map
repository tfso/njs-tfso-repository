{"version":3,"file":"templateliteralvisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/templateliteralvisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\n\nimport { ITemplateLiteralExpression, TemplateLiteralExpression } from './templateliteralexpression';\nimport { IObjectExpression, ObjectExpression, IObjectProperty } from './objectexpression';\n\nimport { JavascriptVisitor } from './javascriptvisitor';\n\nexport class TemplateLiteralVisitor extends JavascriptVisitor {\n    private _wrapper: (value: any) => string;\n\n    constructor(wrapper?: (value: any) => string) {\n        super();\n\n        this._wrapper = wrapper || ((value: any) => value);\n    }\n\n    //public visitTemplateLiteral(expression: ITemplateLiteralExpression): IExpression {\n    //    let elements = expression.elements.map((element) => element.accept(this));\n\n    //    if (elements.every(expr => expr.type == ExpressionType.Literal)) \n    //    {\n    //        return new LiteralExpression(elements.reduce((output, expr) => {\n    //            return output + new String((<ILiteralExpression>expr).value).toString();\n    //        }, ''));\n    //    }\n\n    //    return new TemplateLiteralExpression(elements);\n    //}\n\n    public evaluate(expression: IExpression, it: Object = null): IExpression {\n        var value: any = null;\n\n        if (expression == null)\n            return null;\n\n        switch (expression.type)\n        {\n            case ExpressionType.TemplateLiteral:\n                let templateExpr: ITemplateLiteralExpression = <ITemplateLiteralExpression>expression,\n                    expressions = templateExpr.expressions.map(expr => this.evaluate(expr, it));\n                \n                if (it)\n                {\n                    if (expressions.every(el => el.type == ExpressionType.Literal) == true) {\n                        return new LiteralExpression(\n                            templateExpr.literals.reduce(\n                                (out, str, idx) => out += str.value + this._wrapper(idx < expressions.length ? (<ILiteralExpression>expressions[idx]).value : ''), \n                                ''\n                            )\n                        );\n                       \n                        //return new LiteralExpression(elements.reduce((out, el) => out += this._wrapper((<ILiteralExpression>el).value), ''));\n                    }\n                }\n\n                return new TemplateLiteralExpression(templateExpr.literals, expressions);\n\n            case ExpressionType.Object:\n                let properties = (<IObjectExpression>expression).properties.map(el => <IObjectProperty>{ key: this.evaluate(el.key, it), value: this.evaluate(el.value, it) });\n\n                if (it)\n                {\n                    if (properties.every(el => el.value.type == ExpressionType.Literal) == true)\n                        return new LiteralExpression(properties.reduce((o, p) => {\n                            o[p.key.type == ExpressionType.Identifier ? (<IdentifierExpression>p.key).name : (<ILiteralExpression>p.key).value] = (<ILiteralExpression>p.value).value;\n                            return o;\n                        }, {}));\n                }\n\n                return new ObjectExpression(properties);\n                \n            default:\n                return super.evaluate(expression, it);\n        }\n\n        //return expression;\n    }\n\n    public static evaluate(predicate: (it: Object, ...param: Array<any>) => any, it: Object): any\n    public static evaluate(expression: IExpression, it: Object): any\n    public static evaluate(expression: IExpression | ((it: Object, ...param: Array<any>) => any), it: Object): any {\n        let reducer = new TemplateLiteralVisitor(),\n            result: IExpression;\n\n        if (typeof expression == 'function')\n            expression = reducer.visitLambda(expression);\n\n        result = reducer.evaluate(expression, it);\n\n        return result.type == ExpressionType.Literal ? (<ILiteralExpression>result).value : undefined;\n    }\n}\n\nexport { IExpression, ExpressionType, ITemplateLiteralExpression }"]}