{"version":3,"file":"odatavisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/odatavisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\r\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\r\nimport { ICompoundExpression } from './compoundexpression';\r\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\r\nimport { IMemberExpression, MemberExpression } from './memberexpression';\r\nimport { IMethodExpression, MethodExpression } from './methodexpression';\r\nimport { IUnaryExpression, UnaryExpression, UnaryOperatorType, UnaryAffixType } from './unaryexpression';\r\nimport { IBinaryExpression, BinaryExpression, BinaryOperatorType } from './binaryexpression';\r\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './logicalexpression';\r\nimport { IConditionalExpression } from './conditionalexpression';\r\nimport { IArrayExpression, ArrayExpression } from './arrayexpression';\r\n\r\nimport { LambdaExpression } from './lambdaexpression';\r\nimport { ReducerVisitor } from './reducervisitor';\r\n\r\nexport class ODataVisitor extends ReducerVisitor {\r\n    constructor() {\r\n        super();\r\n    }\r\n    \r\n    public visitOData(filter: string): IExpression {\r\n        return super.visitOData(filter);\r\n    }\r\n\r\n    public get it(): string {\r\n        return \"\";\r\n    }\r\n\r\n    public visitMethod(expression: IMethodExpression): IExpression {\r\n        let parameters = expression.parameters.map((arg) => arg.accept(this)),\r\n            caller: IExpression = undefined,\r\n            name: string = undefined\r\n\r\n        \r\n        let params: Array<any>;\r\n\r\n        // routine to get all parameters that is a literal, eg; solvable\r\n        let getParams = (expression: IMethodExpression, ...typeofs: Array<string>) => {\r\n            let params: Array<any> = null,\r\n                getType = (t) => {\r\n                    if (typeof t == 'object') {\r\n                        if (t.getTime && t.getTime() >= 0)\r\n                            return 'date';\r\n                    }\r\n\r\n                    return typeof t;\r\n                };\r\n\r\n            try {\r\n                if (parameters.every(expression => expression.type == ExpressionType.Literal) == true) {\r\n                    params = parameters.map(expr => (<LiteralExpression>expr).value);\r\n\r\n                    if (new RegExp('^' + typeofs.map(t => t.endsWith('?') ? '(' + t.slice(0, -1) + ')?' : t).join(';') + ';?$').test(params.map(p => getType(p)).join(';') + ';') == false)\r\n                        throw new TypeError(params.map(p => getType(p)).join(', '));\r\n                }\r\n                else if ((parameters.length == typeofs.length) == false) {\r\n                    throw new Error();\r\n                }\r\n            }\r\n            catch (ex) {\r\n                throw new Error('Method \"' + expression.name + '\" requires parameters of (' + typeofs.join(', ') + ')' + (ex.name == 'TypeError' ? ', but got \"' + ex.message + '\"' : ''));\r\n            }\r\n\r\n            return params;\r\n        }\r\n\r\n        switch (expression.name) {\r\n            // String Functions\r\n            case 'substringof': // bool substringof(string po, string p1)\r\n                if ((params = getParams(expression, 'string', 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).indexOf(String(params[1])) >= 0);\r\n\r\n                break;\r\n\r\n            case 'endswith': // bool endswith(string p0, string p1)\r\n                if ((params = getParams(expression, 'string', 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).endsWith(String(params[1])));\r\n\r\n                break;\r\n\r\n            case 'startswith': // bool startswith(string p0, string p1)\r\n                if ((params = getParams(expression, 'string', 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).startsWith(String(params[1])));\r\n\r\n                break;\r\n\r\n            case 'contains': // bool contains(string p0, string p1)\r\n                if ((params = getParams(expression, 'string', 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).indexOf(String(params[1])) >= 0);\r\n\r\n                break;\r\n            case 'length': // int length(string p0)\r\n                if ((params = getParams(expression, 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).length);\r\n                \r\n                break;\r\n\r\n            case 'indexof': // int indexof(string p0, string p1)\r\n                if ((params = getParams(expression, 'string', 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).indexOf(String(params[1])));\r\n\r\n                break;\r\n\r\n            case 'replace': // string replace(string p0, string find, string replace)\r\n                if ((params = getParams(expression, 'string', 'string', 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).replace(String(params[1]), String(params[2])));\r\n\r\n                break;\r\n\r\n            case 'substring': // string substring(string p0, int pos, int? length)\r\n                if ((params = getParams(expression, 'string', 'number', 'number?')) != null)\r\n                    return new LiteralExpression(String(params[0]).replace(String(params[1]), String(params[2])));\r\n\r\n                break;\r\n                    \r\n            case 'tolower': // string tolower(string p0)\r\n                if ((params = getParams(expression, 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).toLowerCase());\r\n\r\n                break;\r\n\r\n            case 'toupper': // string toupper(string p0)\r\n                if ((params = getParams(expression, 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).toUpperCase());\r\n\r\n                break;\r\n\r\n            case 'trim': // string trim(string p0)\r\n                if ((params = getParams(expression, 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]).trim());\r\n\r\n                break;\r\n\r\n            case 'concat': // string concat(string p0, string p1)\r\n                if ((params = getParams(expression, 'string', 'string')) != null)\r\n                    return new LiteralExpression(String(params[0]) + String(params[1]));\r\n\r\n                break;\r\n\r\n            // Date Functions\r\n            case 'day': // int day(DateTime p0)\r\n                if ((params = getParams(expression, 'date')) != null)\r\n                    return new LiteralExpression((<Date>params[0]).getDate());\r\n\r\n                break;\r\n                        \r\n            case 'hour': // int hour(DateTime p0)\r\n                if ((params = getParams(expression, 'date')) != null)\r\n                    return new LiteralExpression((<Date>params[0]).getUTCHours());\r\n\r\n                break;\r\n\r\n            case 'minute': // int minute(DateTime p0)\r\n                if ((params = getParams(expression, 'date')) != null)\r\n                    return new LiteralExpression((<Date>params[0]).getUTCMinutes());\r\n\r\n                break;\r\n\r\n            case 'month': // int month(DateTime p0)\r\n                if ((params = getParams(expression, 'date')) != null)\r\n                    return new LiteralExpression((<Date>params[0]).getMonth() + 1);\r\n\r\n                break;\r\n\r\n            case 'second': // int second(DateTime p0)\r\n                if ((params = getParams(expression, 'date')) != null)\r\n                    return new LiteralExpression((<Date>params[0]).getSeconds());\r\n\r\n                break;\r\n\r\n            case 'year': // int year(DateTime p0)\r\n                if ((params = getParams(expression, 'date')) != null)\r\n                    return new LiteralExpression((<Date>params[0]).getFullYear());\r\n\r\n                break;\r\n\r\n            // Math Functions\r\n            case 'round': // number round(number p0)\r\n                if ((params = getParams(expression, 'number')) != null)\r\n                    return new LiteralExpression(Math.round(Number(params[0])));\r\n\r\n                break;\r\n\r\n            case 'floor': // number floor(number p0)\r\n                if ((params = getParams(expression, 'number')) != null)\r\n                    return new LiteralExpression(Math.floor(Number(params[0])));\r\n\r\n                break;\r\n\r\n            case 'ceiling': // number ceiling(number p0)\r\n                if ((params = getParams(expression, 'number')) != null)\r\n                    return new LiteralExpression(Math.ceil(Number(params[0])));\r\n\r\n                break;\r\n\r\n            // Type Functions\r\n            //case 'isof': // bool IsOf(type p0) | bool IsOf(expression p0, type p1)\r\n\r\n            default:\r\n                throw new Error('OData visitor does not support function \"' + expression.name + '\"');\r\n        }\r\n\r\n        return new MethodExpression(expression.name, parameters, caller);\r\n    }\r\n\r\n    public static evaluate(expression: string, it?: Object): any\r\n    public static evaluate(expression: IExpression, it?: Object): any\r\n    public static evaluate(expression: IExpression | string, it: Object = null): any {\r\n        let reducer = new ODataVisitor(),\r\n            result: IExpression;\r\n\r\n        if (typeof expression == 'string')\r\n            expression = reducer.visitOData(expression);\r\n\r\n        result = reducer.evaluate(expression, it);\r\n\r\n        return result.type == ExpressionType.Literal ? (<ILiteralExpression>result).value : undefined;\r\n    }\r\n\r\n}"]}