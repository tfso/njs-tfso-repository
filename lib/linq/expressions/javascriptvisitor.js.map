{"version":3,"file":"javascriptvisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/javascriptvisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\nimport { IMemberExpression, MemberExpression } from './memberexpression';\nimport { IMethodExpression, MethodExpression } from './methodexpression';\n\nimport { LambdaExpression } from './lambdaexpression';\nimport { ReducerVisitor } from './reducervisitor';\n\nexport class JavascriptVisitor extends ReducerVisitor {\n    constructor() {\n        super();\n    }\n\n    public visitMember(expression: IMemberExpression): IExpression {\n        return super.visitMember(expression)\n    }\n    \n    public visitMethod(expression: IMethodExpression): IExpression {\n        let parameters = expression.parameters.map((arg) => arg.accept(this)),\n            caller: IExpression = expression.caller ? expression.caller.accept(this) : null,\n            name: string = expression.name\n\n        if (caller)\n        {\n            let value: any = undefined,\n                params = parameters.map(expr => expr.type == ExpressionType.Literal ? (<ILiteralExpression>expr).value : undefined);\n\n            switch (caller.type)\n            {\n                case ExpressionType.Identifier: \n                    switch ((<IIdentifierExpression>caller).name)\n                    {\n                        case 'Math':\n                            switch (name)\n                            {\n                                case 'abs':\n                                case 'acos':\n                                case 'acosh':\n                                case 'asin':\n                                case 'asinh':\n                                case 'atan':\n                                case 'atanh':\n                                case 'atan2':\n                                case 'cbrt':\n                                case 'ceil':\n                                case 'clz32':\n                                case 'cos':\n                                case 'cosh':\n                                case 'exp':\n                                case 'expm1':\n                                case 'floor':\n                                case 'fround':\n                                case 'hypot':\n                                case 'imul':\n                                case 'log':\n                                case 'log1p':\n                                case 'log10':\n                                case 'log2':\n                                case 'max':\n                                case 'min':\n                                case 'pow':\n                                case 'random':\n                                case 'round':\n                                case 'sign':\n                                case 'sin':\n                                case 'sinh':\n                                case 'sqrt':\n                                case 'tan':\n                                case 'tanh':\n                                case 'trunc':\n                                    return new LiteralExpression(Math[name].call(null, ...params));\n                            }\n                    }\n\n                    break;\n\n                case ExpressionType.Literal:\n                    switch (typeof (value = (<ILiteralExpression>caller).value))\n                    {\n                        case 'string':\n                            switch (name)\n                            {\n                                case 'charAt':\n                                case 'charCodeAt':\n                                case 'concat':\n                                case 'includes':\n                                case 'endsWith':\n                                case 'indexOf':\n                                case 'lastIndexOf':\n                                case 'localeCompare':\n                                case 'match':\n                                case 'normalize':\n                                case 'padEnd':\n                                case 'padStart':\n                                case 'repeat':\n                                case 'replace':\n                                case 'search':\n                                case 'slice':\n                                case 'split':\n                                case 'startsWith':\n                                case 'substr':\n                                case 'substring':\n                                case 'toLocaleLowerCase':\n                                case 'toLocaleUpperCase':\n                                case 'toLowerCase':\n                                case 'toString':\n                                case 'toUpperCase':\n                                case 'trim':\n                                    return new LiteralExpression(String.prototype[name].call(value, ...params));\n\n                                default:\n                                    break;\n                            }\n\n                            break;\n\n                        case 'number':\n                            switch (name)\n                            {\n                                case 'isNaN':\n                                case 'isFinitie':\n                                case 'isInteger':\n                                case 'isSafeInteger':\n                                case 'parseFloat':\n                                case 'parseInt':\n                                case 'toExponential':\n                                case 'toFixed':\n                                case 'toLocaleString':\n                                case 'toPrecision':\n                                case 'toString':\n                                    return new LiteralExpression(Number.prototype[name].call(value, ...params));\n                            }\n                            break;\n\n                        case 'object':\n                            if (value.getTime && value.getTime() >= 0)\n                                break;\n\n                            if (Array.isArray(value) == true)\n                                break;\n\n                            break;\n\n\n                    }\n\n                    break;\n            }\n        }\n\n        return new MethodExpression(name, parameters, caller);\n    }\n\n    public static evaluate(predicate: (it: Object, ...param: Array<any>) => any, it: Object): any\n    public static evaluate(expression: IExpression, it: Object): any\n    public static evaluate(expression: IExpression | ((it: Object, ...param: Array<any>) => any), it: Object): any {\n        let reducer = new JavascriptVisitor(),\n            result: IExpression;\n\n        if (typeof expression == 'function')\n            expression = reducer.visitLambda(expression);\n\n        result = reducer.evaluate(expression, it);\n\n        return result.type == ExpressionType.Literal ? (<ILiteralExpression>result).value : undefined;\n    }\n\n}"]}