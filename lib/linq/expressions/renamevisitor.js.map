{"version":3,"file":"renamevisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/renamevisitor.ts"],"names":[],"mappings":";;AAAA,6CAAuE;AACvE,iEAAqF;AACrF,yDAAyE;AAEzE,2DAAwD;AAExD,mBAA2B,SAAQ,qCAAiB;IAGhD,YAAY,GAAG,OAA4C;QACvD,KAAK,EAAE,CAAC;QAER,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;QAEzB,GAAG,CAAC,CAAC,IAAI,MAAM,IAAI,OAAO,CAAC;YACvB,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,QAAQ,IAAI,OAAO,MAAM,CAAC,IAAI,IAAI,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;gBACxF,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC;IACrD,CAAC;IAEM,KAAK,CAAC,UAAuB;QAChC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACnC,CAAC;IAEM,eAAe,CAAC,UAAiC;QACpD,IAAI,IAAI,CAAC;QAET,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC;YACnD,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;QAE3B,MAAM,CAAC,IAAI,2CAAoB,CAAC,IAAI,CAAC,CAAC;IAC1C,CAAC;IAEM,WAAW,CAAC,UAA6B;QAC5C,IAAI,IAAY,CAAC;QAEjB,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC;YAClE,MAAM,CAAC,IAAI,mCAAgB,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,UAAU,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;QAElG,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACtC,CAAC;IAEO,aAAa,CAAC,UAAuB;QACzC,MAAM,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;YACtB,KAAK,2BAAc,CAAC,MAAM;gBACtB,IAAI,IAAI,GAAG,IAAI,CAAC,aAAa,CAAqB,UAAW,CAAC,QAAQ,CAAC,CAAC;gBAExE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAqB,UAAW,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;YAE5G,KAAK,2BAAc,CAAC,UAAU;gBAC1B,MAAM,CAAyB,UAAW,CAAC,IAAI,CAAC;YAEpD;gBACI,MAAM,CAAC,EAAE,CAAC;QAClB,CAAC;IACL,CAAC;IAEO,eAAe,CAAC,IAAY,EAAE,MAAc,CAAC;QACjD,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAE5B,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC;YACxB,MAAM,CAAC,IAAI,2CAAoB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;QAEhD,MAAM,CAAC,IAAI,mCAAgB,CAAC,IAAI,2CAAoB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3G,CAAC;CAEJ;AA3DD,sCA2DC","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\nimport { IMemberExpression, MemberExpression } from './memberexpression';\n\nimport { ExpressionVisitor } from './expressionvisitor';\n\nexport class RenameVisitor extends ExpressionVisitor {\n    private renames: Map<string, string>;\n\n    constructor(...renames: Array<{ from: string, to: string }>) {\n        super();\n\n        this.renames = new Map();\n        \n        for (let rename of renames)\n            if (typeof (rename) == 'object' && typeof rename.from == 'string' && rename.from.length > 0)\n                this.renames.set(rename.from, rename.to);\n    }\n\n    public visit(expression: IExpression): IExpression {\n        return expression.accept(this);\n    }\n\n    public visitIdentifier(expression: IIdentifierExpression): IExpression {\n        let name;\n\n        if ((name = this.renames.get(expression.name)) == null)\n            name = expression.name;\n\n        return new IdentifierExpression(name);\n    }\n\n    public visitMember(expression: IMemberExpression): IExpression {       \n        let path: string;\n   \n        if ((path = this.renames.get(this.flattenMember(expression))) == null)\n            return new MemberExpression(expression.object.accept(this), expression.property.accept(this));\n\n        return this.unflattenMember(path);\n    }\n\n    private flattenMember(expression: IExpression): string {\n        switch (expression.type) {\n            case ExpressionType.Member:\n                let prop = this.flattenMember((<IMemberExpression>expression).property);\n\n                return this.flattenMember((<IMemberExpression>expression).object) + (prop.length > 0 ? '.' + prop : '');\n                \n            case ExpressionType.Identifier:\n                return (<IIdentifierExpression>expression).name;\n\n            default:\n                return \"\";\n        }\n    }\n\n    private unflattenMember(path: string, idx: number = 0): IExpression {\n        let parts = path.split('.');\n\n        if (idx + 1 >= parts.length)\n            return new IdentifierExpression(parts[idx]);\n\n        return new MemberExpression(new IdentifierExpression(parts[idx]), this.unflattenMember(path, idx + 1));\n    }\n\n}\n"]}