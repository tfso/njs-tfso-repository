{"version":3,"file":"skipwhileoperator.js","sourceRoot":"","sources":["../../../src/linq/operators/skipwhileoperator.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator, OperatorType } from './operator';\n\nimport { IExpression, ExpressionType } from './../expressions/expression';\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './../expressions/logicalexpression';\nimport { MemberExpression } from './../expressions/memberexpression';\nimport { IdentifierExpression } from './../expressions/identifierexpression';\n\nimport { ReducerVisitor } from './../expressions/reducervisitor';\nimport { ODataVisitor } from './../expressions/odatavisitor';\n\nexport type PredicateType = 'Javascript' | 'OData';\n\nexport class SkipWhileOperator<TEntity> extends Operator<TEntity> {\n    private _predicate: (entity: TEntity) => boolean;\n    private _expression: IExpression;\n\n    private _it: string;\n    private _footprint: string\n\n    constructor(predicateType: 'OData', predicate: string)\n    constructor(predicateType: 'Javascript', predicate: (it: TEntity, ...param: any[]) => boolean, ...parameters: Array<any>)\n    constructor(predicateType: PredicateType, predicate: any, ...parameters: any[]) {\n        super(OperatorType.SkipWhile);\n\n        switch (predicateType) {\n            case 'Javascript':\n                let visitor: ReducerVisitor;\n\n                this._expression = (visitor = new ReducerVisitor()).visitLambda(predicate, ...parameters);\n                this._it = visitor.it;\n\n                this._footprint = new Object(predicate).toString();\n                this._predicate = (entity: TEntity) => {\n                    return predicate.apply({}, [entity].concat(parameters)) === true;\n                };\n                \n                break;\n\n            case 'OData':\n                this._expression = new ODataVisitor().visitOData(predicate);\n                this._it = \"\";\n\n                this._footprint = predicate;\n                this._predicate = (entity: TEntity) => {\n                    return ODataVisitor.evaluate(this._expression, entity) === true;\n                }\n                \n                break;\n        }\n    }\n\n    public get predicate(): (entity: TEntity) => boolean {\n        return this._predicate == null ? () => true : this._predicate;\n    }\n\n    public get expression(): IExpression {\n        return this._expression;\n    }\n\n    public set expression(value: IExpression) {\n        this._expression = value;\n    }\n\n    public* evaluate(items: Iterable<TEntity>): IterableIterator<TEntity> {\n        let skip = true;\n\n        for (let item of items) {\n            if(this.removed == false && skip && (skip = this._predicate(item)) == true)\n                continue;\n\n            yield item;\n        }\n    }\n    \n    public async * evaluateAsync(items: AsyncIterable<TEntity>): AsyncIterableIterator<TEntity> {    \n        let skip = true;\n\n        for await (let item of items) {\n            if (this.removed == false && skip && (skip = this._predicate(item)) == true)\n                continue;\n                \n            yield item;\n        }\n    }\n\n    public getExpressionIntersection(): ILogicalExpression[] {\n        let intersection: Array<ILogicalExpression>;\n\n        intersection = Array.from(this.getExpressionGroups()).reduce((acc, curr, idx) => {\n            return Array.from(curr).filter((expr) => {\n                return !acc || acc.some(intersect => expr.equal(intersect));\n            });\n        }, intersection);\n\n        return intersection || [];\n    }\n\n    public getExpressionUnion(): ILogicalExpression[] {\n        let union: Array<ILogicalExpression>;\n\n        union = Array.from(this.getExpressionGroups()).reduce((acc, curr, idx) => {\n            return (acc || []).concat(Array.from(curr));\n        }, union);\n\n        return union || [];\n    }\n\n    public getExpressionCount(): number {\n        let visit = (expression: IExpression) : number => {\n\n            switch (expression.type)\n            {\n                case ExpressionType.Logical:\n                    switch ((<LogicalExpression>expression).operator)\n                    {\n                        case LogicalOperatorType.And:\n                        case LogicalOperatorType.Or:\n                            return visit((<LogicalExpression>expression).left) + visit((<LogicalExpression>expression).right);\n\n                        default:\n                            return 1;\n                    }\n\n                default:\n                    return 0;\n            }\n        }\n\n        return visit(this.expression);\n    }\n\n    private getExpressionGroups(): Iterable<IterableIterator<ILogicalExpression>> {\n        let it = this._it,\n            visit = function* (expression: IExpression): Iterable<IterableIterator<ILogicalExpression>> {\n                let visitGroup = function* (child: LogicalExpression): IterableIterator<ILogicalExpression> {\n                    switch (child.operator) {\n                        case LogicalOperatorType.Or:\n                            break;\n\n                        case LogicalOperatorType.And:\n                            if (child.left instanceof LogicalExpression) yield* visitGroup(child.left);\n                            if (child.right instanceof LogicalExpression) yield* visitGroup(child.right);\n                            break;\n\n                        default:                      \n                            let reduceMemberToIdentifier = (expr: IExpression): IExpression => {\n                                switch (expr.type) {\n                                    case ExpressionType.Logical:\n                                        let left = reduceMemberToIdentifier((<LogicalExpression>expr).left),\n                                            right = reduceMemberToIdentifier((<LogicalExpression>expr).right);\n\n                                        if ((left.type == ExpressionType.Identifier || left.type == ExpressionType.Member || left.type == ExpressionType.Method) == false) {\n                                            switch ((<LogicalExpression>expr).operator) {\n                                                case LogicalOperatorType.And:\n                                                case LogicalOperatorType.Or:\n                                                case LogicalOperatorType.NotEqual:\n                                                case LogicalOperatorType.Equal:\n                                                    return new LogicalExpression((<LogicalExpression>expr).operator, left, right);\n\n                                                case LogicalOperatorType.Greater: // 5 > 2 == 2 < 5\n                                                    return new LogicalExpression(LogicalOperatorType.Lesser, right, left);\n\n                                                case LogicalOperatorType.GreaterOrEqual: // 5 >= 2 == 2 <= 5\n                                                    return new LogicalExpression(LogicalOperatorType.LesserOrEqual, right, left);\n\n                                                case LogicalOperatorType.Lesser: // 5 < 2 == 2 > 5\n                                                    return new LogicalExpression(LogicalOperatorType.Greater, right, left);\n\n                                                case LogicalOperatorType.LesserOrEqual: // 5 <= 2 == 2 >= 5\n                                                    return new LogicalExpression(LogicalOperatorType.GreaterOrEqual, right, left);\n                                            }\n                                        }\n\n                                        return new LogicalExpression((<LogicalExpression>expr).operator, left, right);\n\n                                    case ExpressionType.Member:\n                                        if ((<MemberExpression>expr).object.type == ExpressionType.Identifier && (<IdentifierExpression>(<MemberExpression>expr).object).name == it)\n                                            return (<MemberExpression>expr).property;\n                                        else\n                                            return expr;\n                                        \n                                    default:\n                                        return expr;\n                                }\n                            }\n\n                            let reduced = reduceMemberToIdentifier(child);\n                            if(reduced.type == ExpressionType.Logical)\n                                yield <ILogicalExpression>reduced;\n                    }\n                }\n\n                if (expression instanceof LogicalExpression) {\n                    if (expression.operator == LogicalOperatorType.Or) {\n                        yield* visit(expression.left);\n                        yield* visit(expression.right);\n                    }\n                    else {\n                        yield visitGroup(expression);\n                    }\n                }\n            };\n\n        // TODO; make a simplifier visitor that returns member expressions at left side an evaluates method call expressions (reduceMemberToIdentifier above does this now);\n        return visit(this.expression);\n    }\n\n    public toString(): string {\n        return this._footprint; // should be this._expression.toString() sooner or later\n    }\n\n    \n}"]}