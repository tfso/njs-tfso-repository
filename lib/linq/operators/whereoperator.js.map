{"version":3,"file":"whereoperator.js","sourceRoot":"","sources":["../../../src/linq/operators/whereoperator.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator, OperatorType } from './operator';\r\n\r\nimport { IExpression, ExpressionType } from './../expressions/expression';\r\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './../expressions/logicalexpression';\r\nimport { MemberExpression } from './../expressions/memberexpression';\r\nimport { IdentifierExpression } from './../expressions/identifierexpression';\r\nimport { IUnaryExpression, UnaryOperatorType, UnaryAffixType } from '../expressions/unaryexpression';\r\n\r\nimport { ReducerVisitor } from './../expressions/reducervisitor';\r\nimport { ODataVisitor } from './../expressions/odatavisitor';\r\n\r\nexport type PredicateType = 'Javascript' | 'OData';\r\n\r\nexport class WhereOperator<TEntity> extends Operator<TEntity> {\r\n    private _predicate: (entity: TEntity) => boolean;\r\n    private _expression: IExpression;\r\n\r\n    private _it: string;\r\n\r\n    private _footprint: string\r\n\r\n    constructor(predicateType: 'OData', predicate: string)\r\n    constructor(predicateType: 'Javascript', predicate: (it: TEntity, ...param: any[]) => boolean, ...parameters: Array<any>)\r\n    constructor(predicateType: PredicateType, predicate: any, ...parameters: any[]) {\r\n        super(OperatorType.Where);\r\n\r\n        //this._parameters = parameters;\r\n\r\n        switch (predicateType) {\r\n            case 'Javascript':\r\n                let visitor: ReducerVisitor;\r\n\r\n                this._expression = (visitor = new ReducerVisitor()).visitLambda(predicate, ...parameters);\r\n                this._it = visitor.it;\r\n\r\n                this._footprint = new Object(predicate).toString();\r\n                this._predicate = (entity: TEntity) => {\r\n                    return predicate.apply({}, [entity].concat(parameters)) === true;\r\n                };\r\n\r\n                //if (visitor.isSolvable == false)\r\n                //    throw new Error('Predicate is not solvable');\r\n\r\n                break;\r\n\r\n            case 'OData':\r\n                this._expression = new ODataVisitor().visitOData(predicate);\r\n                this._it = \"\";\r\n\r\n                this._footprint = predicate;\r\n                this._predicate = (entity: TEntity) => {\r\n                    return ODataVisitor.evaluate(this._expression, entity) === true;\r\n                }\r\n                \r\n                break;\r\n        }\r\n    }\r\n\r\n    //public get parameters(): any[] {\r\n    //    return this._parameters;\r\n    //}\r\n\r\n    public get predicate(): (entity: TEntity) => boolean {\r\n        return this._predicate == null ? () => true : this._predicate;\r\n    }\r\n\r\n    public get expression(): IExpression {\r\n        return this._expression;\r\n    }\r\n\r\n    public set expression(value: IExpression) {\r\n        this._expression = value;\r\n    }\r\n\r\n    public* evaluate(items: Iterable<TEntity>): IterableIterator<TEntity> {\r\n        for (let item of items)\r\n            if (this._predicate(item)) yield item;\r\n    }\r\n    \r\n    public async * evaluateAsync(items: AsyncIterable<TEntity>): AsyncIterableIterator<TEntity> {    \r\n        for await (let item of items)\r\n            if (this._predicate(item)) yield item;\r\n    }\r\n\r\n    public getExpressionIntersection(): ILogicalExpression[] {\r\n        let intersection: Array<ILogicalExpression>;\r\n\r\n        intersection = Array.from(this.getExpressionGroups()).reduce((acc, curr, idx) => {\r\n            return Array.from(curr).filter((expr) => {\r\n                return !acc || acc.some(intersect => expr.equal(intersect));\r\n            });\r\n        }, intersection);\r\n\r\n        return intersection || [];\r\n    }\r\n\r\n    public getExpressionUnion(): ILogicalExpression[] {\r\n        let union: Array<ILogicalExpression>;\r\n\r\n        union = Array.from(this.getExpressionGroups()).reduce((acc, curr, idx) => {\r\n            return (acc || []).concat(Array.from(curr));\r\n        }, union);\r\n\r\n        return union || [];\r\n    }\r\n\r\n    public getExpressionCount(): number {\r\n        let visit = (expression: IExpression) : number => {\r\n\r\n            switch (expression.type)\r\n            {\r\n                case ExpressionType.Logical:\r\n                    switch ((<LogicalExpression>expression).operator)\r\n                    {\r\n                        case LogicalOperatorType.And:\r\n                        case LogicalOperatorType.Or:\r\n                            return visit((<LogicalExpression>expression).left) + visit((<LogicalExpression>expression).right);\r\n\r\n                        default:\r\n                            return 1;\r\n                    }\r\n\r\n                default:\r\n                    return 0;\r\n            }\r\n        }\r\n\r\n        return visit(this.expression);\r\n    }\r\n\r\n    public getExpressionGroups(): Iterable<IterableIterator<ILogicalExpression>> {\r\n        let it = this._it,\r\n            visit = function* (expression: IExpression): Iterable<IterableIterator<ILogicalExpression>> {\r\n                let visitGroup = function* (child: LogicalExpression): IterableIterator<ILogicalExpression> {\r\n                    switch (child.operator) {\r\n                        case LogicalOperatorType.Or:\r\n                            break;\r\n\r\n                        case LogicalOperatorType.And:\r\n                            if (child.left instanceof LogicalExpression) yield* visitGroup(child.left);\r\n                            if (child.right instanceof LogicalExpression) yield* visitGroup(child.right);\r\n                            break;\r\n\r\n                        default:                      \r\n                            let reduceMemberToIdentifier = (expr: IExpression): IExpression => {\r\n                                switch (expr.type) {\r\n                                    case ExpressionType.Logical:\r\n                                        let left = reduceMemberToIdentifier((<LogicalExpression>expr).left),\r\n                                            right = reduceMemberToIdentifier((<LogicalExpression>expr).right);\r\n\r\n                                        if ((left.type == ExpressionType.Identifier || left.type == ExpressionType.Member || left.type == ExpressionType.Method) == false) {\r\n                                            switch ((<LogicalExpression>expr).operator) {\r\n                                                case LogicalOperatorType.And:\r\n                                                case LogicalOperatorType.Or:\r\n                                                case LogicalOperatorType.NotEqual:\r\n                                                case LogicalOperatorType.Equal:\r\n                                                    return new LogicalExpression((<LogicalExpression>expr).operator, left, right);\r\n\r\n                                                case LogicalOperatorType.Greater: // 5 > 2 == 2 < 5\r\n                                                    return new LogicalExpression(LogicalOperatorType.Lesser, right, left);\r\n\r\n                                                case LogicalOperatorType.GreaterOrEqual: // 5 >= 2 == 2 <= 5\r\n                                                    return new LogicalExpression(LogicalOperatorType.LesserOrEqual, right, left);\r\n\r\n                                                case LogicalOperatorType.Lesser: // 5 < 2 == 2 > 5\r\n                                                    return new LogicalExpression(LogicalOperatorType.Greater, right, left);\r\n\r\n                                                case LogicalOperatorType.LesserOrEqual: // 5 <= 2 == 2 >= 5\r\n                                                    return new LogicalExpression(LogicalOperatorType.GreaterOrEqual, right, left);\r\n                                            }\r\n                                        }\r\n\r\n                                        return new LogicalExpression((<LogicalExpression>expr).operator, left, right);\r\n\r\n                                    case ExpressionType.Member:\r\n                                        if ((<MemberExpression>expr).object.type == ExpressionType.Identifier && (<IdentifierExpression>(<MemberExpression>expr).object).name == it)\r\n                                            return (<MemberExpression>expr).property;\r\n                                        else\r\n                                            return expr;\r\n                                        \r\n                                    case ExpressionType.Unary:\r\n                                        switch( (<IUnaryExpression>expr).operator ) {\r\n                                            case UnaryOperatorType.Positive:\r\n                                                return reduceMemberToIdentifier((<IUnaryExpression>expr).argument);\r\n                                        }\r\n\r\n                                    default:\r\n                                        return expr;\r\n                                }\r\n                            }\r\n\r\n                            let reduced = reduceMemberToIdentifier(child);\r\n                            if(reduced.type == ExpressionType.Logical)\r\n                                yield <ILogicalExpression>reduced;\r\n                    }\r\n                }\r\n\r\n                if (expression instanceof LogicalExpression) {\r\n                    if (expression.operator == LogicalOperatorType.Or) {\r\n                        yield* visit(expression.left);\r\n                        yield* visit(expression.right);\r\n                    }\r\n                    else {\r\n                        yield visitGroup(expression);\r\n                    }\r\n                }\r\n            };\r\n\r\n        // TODO; make a simplifier visitor that returns member expressions at left side an evaluates method call expressions (reduceMemberToIdentifier above does this now);\r\n        return visit(this.expression);\r\n    }\r\n\r\n    public toString(): string {\r\n        return this._footprint; // should be this._expression.toString() sooner or later\r\n    }\r\n\r\n    \r\n}"]}