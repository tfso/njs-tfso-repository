{"version":3,"file":"orderbyoperator.js","sourceRoot":"","sources":["../../../src/linq/operators/orderbyoperator.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yCAAoD;AACpD,0EAA8I;AAE9I,MAAa,eAAyB,SAAQ,mBAAiB;IAG3D,YAAY,QAA0D;QAClE,KAAK,CAAC,uBAAY,CAAC,OAAO,CAAC,CAAC;QAE5B,IAAG,OAAO,QAAQ,IAAI,UAAU,EAAE;YAC9B,IAAI,UAAU,GAAG,IAAI,qCAAiB,EAAE,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;YAE/D,IAAI,UAAU,CAAC,IAAI,IAAI,kCAAc,CAAC,MAAM;gBACxC,MAAM,IAAI,SAAS,CAAC,6DAA6D,CAAC,CAAC;YAEvF,IAAwB,UAAW,CAAC,QAAQ,CAAC,IAAI,IAAI,kCAAc,CAAC,UAAU;gBAC1E,MAAM,IAAI,SAAS,CAAC,6DAA6D,CAAC,CAAC;YAEvF,IAAI,CAAC,QAAQ,GAA+C,UAAW,CAAC,QAAS,CAAC,IAAI,CAAA;SACzF;aACI;YACD,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAA;SAC3B;IACL,CAAC;IAEM,CAAE,QAAQ,CAAC,KAAwB;QACtC,IAAI,EAAE,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC3B,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;YACb,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACnG,CAAC,CAAC,CAAA;QAEF,KAAK,CAAC,CAAC,EAAE,CAAC;IACd,CAAC;IAEc,aAAa,CAAC,KAA6B;;;YACtD,IAAI,EAAE,GAAmB,EAAE,CAAC;;gBAC5B,KAAsB,IAAA,UAAA,cAAA,KAAK,CAAA,WAAA;oBAAjB,IAAI,IAAI,kBAAA,CAAA;oBACd,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAAA;;;;;;;;;YAElB,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;gBACb,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACnG,CAAC,CAAC,CAAA;YAEF,cAAA,KAAK,CAAC,CAAC,iBAAA,cAAA,EAAE,CAAA,CAAA,CAAA,CAAC;QACd,CAAC;KAAA;CACJ;AA1CD,0CA0CC","sourcesContent":["import { Operator, OperatorType } from './operator';\r\nimport { ExpressionVisitor, IExpression, ExpressionType, IMemberExpression, IIdentifierExpression } from './../expressions/expressionvisitor';\r\n\r\nexport class OrderByOperator<TEntity> extends Operator<TEntity> {\r\n    public property: string | number | symbol\r\n\r\n    constructor(property: string | keyof TEntity | ((it: TEntity) => void)) {\r\n        super(OperatorType.OrderBy);\r\n\r\n        if(typeof property == 'function') {\r\n            let expression = new ExpressionVisitor().visitLambda(property);\r\n\r\n            if (expression.type != ExpressionType.Member)\r\n                throw new TypeError('Order by is expecting a member property as sorting property');\r\n\r\n            if ((<IMemberExpression>expression).property.type != ExpressionType.Identifier)\r\n                throw new TypeError('Order by is expecting a member property as sorting property');\r\n\r\n            this.property = (<IIdentifierExpression>(<IMemberExpression>expression).property).name\r\n        }\r\n        else {\r\n            this.property = property\r\n        }\r\n    }\r\n\r\n    public * evaluate(items: Iterable<TEntity>): IterableIterator<TEntity> {\r\n        let ar = Array.from(items);\r\n        ar.sort((a, b) => {\r\n            return a[this.property] == b[this.property] ? 0 : a[this.property] < b[this.property] ? -1 : 1;\r\n        })\r\n\r\n        yield* ar;\r\n    }\r\n\r\n    public async * evaluateAsync(items: AsyncIterable<TEntity>): AsyncIterableIterator<TEntity> {\r\n        let ar: Array<TEntity> = [];\r\n        for await(let item of items)\r\n            ar.push(item);\r\n\r\n        ar.sort((a, b) => {\r\n            return a[this.property] == b[this.property] ? 0 : a[this.property] < b[this.property] ? -1 : 1;\r\n        })\r\n\r\n        yield* ar;   \r\n    }\r\n}"]}