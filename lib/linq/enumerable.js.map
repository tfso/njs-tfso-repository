{"version":3,"file":"enumerable.js","sourceRoot":"","sources":["../../src/linq/enumerable.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator, OperatorType } from './operators/operator';\r\nimport { OrderByOperator } from './operators/orderbyoperator';\r\nimport { SkipOperator } from './operators/skipoperator';\r\nimport { SkipWhileOperator } from './operators/skipwhileoperator';\r\nimport { TakeOperator } from './operators/takeoperator';\r\nimport { WhereOperator } from './operators/whereoperator';\r\nimport { SelectOperator } from './operators/selectoperator';\r\nimport { JoinOperator, JoinType } from './operators/joinoperator';\r\nimport { SliceOperator } from './operators/sliceoperator';\r\n\r\nimport { RenameVisitor } from './expressions/renamevisitor';\r\nimport { RemapVisitor } from './expressions/remapvisitor';\r\n\r\nimport { Operations } from './operations';\r\n\r\nexport { OperatorType };\r\n\r\nexport interface IEnumerableOptions<TEntity> {\r\n    query?: IEnumerable<TEntity>\r\n    parent?: IEnumerable<any>\r\n}\r\n\r\nexport interface IEnumerable<TEntity> extends Iterable<TEntity>, AsyncIterable<TEntity> {\r\n    readonly operations: Operations<TEntity>\r\n\r\n    from(items: Array<TEntity>)\r\n    from(items: Iterable<TEntity>)\r\n    from(items: AsyncIterable<TEntity>)\r\n\r\n    /**\r\n     * A remapper of identifier names, members is seperated with dot.\r\n     * @param remapper Function that returns the new name of the identifier\r\n     */\r\n    remap<TResult>(remapper: (name: string) => string) : IEnumerable<TResult>\r\n    /**\r\n     * A remapper of values that corresponds to a identifier name\r\n     * @param remapper Function that returns the new value\r\n     */\r\n    remap<TResult>(remapper: (name: string, value: any) => any) : IEnumerable<TResult>\r\n\r\n    /**\r\n    * Where clause using OData $filter expression returning either true or false. Any parameters used is properties of TEntity\r\n    * @param predicate OData expression\r\n    */\r\n    where(predicate: string): this\r\n    /**\r\n     * Where clause using Javascript expression returning either true or false\r\n     * @param predicate javascript expression\r\n     * @param parameters any javascript parameters has to be declared\r\n     */\r\n    where(predicate: (it: TEntity, ...param: any[]) => boolean, ...parameters: any[]): this\r\n\r\n    orderBy(property: (it: TEntity) => void): this\r\n\r\n    //range(start: number, count: number): this\r\n    \r\n    /**\r\n     * Bypasses a specified number of elements in a sequence and then returns the remaining elements\r\n     * @param count The number of elements to skip before returning the remaining elements\r\n     */\r\n    skip(count: number): this\r\n\r\n    /**\r\n     * Bypassing elements using OData $filter expression as long as specified condition is true and then returns the remaining elements\r\n     * @param predicate OData expression\r\n     */\r\n    skipWhile(predicate: string): this\r\n    /**\r\n     * Bypassing elements using Javascript expression as long as specified condition is true and then returns the remaining elements\r\n     * @param predicate javascript expression\r\n     * @param parameters any javascript parameters has to be declared\r\n     */\r\n    skipWhile(predicate: (it: TEntity, ...param: any[]) => boolean, ...parameters: any[]): this\r\n\r\n    /**\r\n     * Returns a specified number of contiguous elements from the start of a sequence.\r\n     * @param count The number of elements to return\r\n     */\r\n    take(count: number): this\r\n    //reverse(): this\r\n\r\n    /**\r\n     * Bypasses all elements before beginning and returns the remaining elements or up to the specified end\r\n     * @param begin zero-based index at which to begin extraction\r\n     * @param end zero-based index before which to end extraction\r\n     */\r\n    slice(begin: number, end?: number): this\r\n    /**\r\n     * Bypasses all elements before beginning and returns the remaining elements\r\n     * Note: If the beginning is not an index it's up to the repository to handle slicing.\r\n     * @param token a token that indicates where to begin extraction\r\n     */\r\n    slice(token: any): this    \r\n\r\n    /**\r\n     * returns a new IEnumerable of TResult (Left Join)\r\n     * @param inner\r\n     * @param outerKey\r\n     * @param innerKey\r\n     * @param selector A function that returns the new object, (outer, inner) => { outer, inner } or (outer, inner) => Object.assign({}, a, { childs: inner.toArray() })\r\n     * @param indexing If set to true an Array of outerKey will be passed into iterator of TInner as { keys: Array<any> }. Cons, all elements of outer iterator will be be kept in memory.\r\n     * @returns IEnumerable<TResult>\r\n     */\r\n    groupJoin<TInner, TResult>(inner: Iterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing?: boolean): IEnumerable<TResult>\r\n    /**\r\n     * returns a new IEnumerable of TResult (Left Join)\r\n     * @param inner\r\n     * @param outerKey\r\n     * @param innerKey\r\n     * @param selector A function that returns the new object, (outer, inner) => { outer, inner } or (outer, inner) => Object.assign({}, a, { childs: inner.toArray() })\r\n     * @param indexing If set to true an Array of outerKey will be passed into iterator of TInner as { keys: Array<any> }. Cons, all elements of outer iterator will be be kept in memory.\r\n     * @returns IEnumerable<TResult>\r\n     */\r\n    groupJoin<TInner, TResult>(inner: AsyncIterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing?: boolean): IEnumerable<TResult> \r\n\r\n    /**\r\n     * returns a new IEnumerable of TResult (Inner Join)\r\n     * @param inner\r\n     * @param outerKey\r\n     * @param innerKey\r\n     * @param selector A function that returns the new object, (outer, inner) => { outer, inner } or (outer, inner) => Object.assign({}, a, { childs: inner.toArray() })\r\n     * @param indexing If set to true an Array of outerKey will be passed into iterator of TInner as { keys: Array<any> }. Cons, all elements of outer iterator will be be kept in memory.\r\n     * @returns IEnumerable<TResult>\r\n     */\r\n    join<TInner, TResult>(inner: Iterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing?: boolean): IEnumerable<TResult> \r\n    /**\r\n     * returns a new IEnumerable of TResult (Inner Join)\r\n     * @param inner\r\n     * @param outerKey\r\n     * @param innerKey\r\n     * @param selector A function that returns the new object, (outer, inner) => { outer, inner } or (outer, inner) => Object.assign({}, a, { childs: inner.toArray() })\r\n     * @param indexing If set to true an Array of outerKey will be passed into iterator of TInner as { keys: Array<any> }. Cons, all elements of outer iterator will be be kept in memory.\r\n     * @returns IEnumerable<TResult>\r\n     */\r\n    join<TInner, TResult>(inner: AsyncIterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing?: boolean): IEnumerable<TResult>\r\n\r\n    /**\r\n    * returns a new IEnumerable of TResult\r\n    * @param selector\r\n    */\r\n    select<TResult>(selector: (it: TEntity) => TResult): IEnumerable<TResult>\r\n\r\n    first(items?: Array<TEntity>): TEntity\r\n    firstAsync(items?: Array<TEntity>): Promise<TEntity>\r\n\r\n    toArray(items: Array<TEntity>): Array<TEntity>\r\n    toArray(): Array<TEntity>\r\n\r\n    toArrayAsync(items: Array<TEntity>): Promise<Array<TEntity>>\r\n    toArrayAsync(): Promise<Array<TEntity>>\r\n\r\n    copy(): IEnumerable<TEntity>\r\n}\r\n\r\nexport class Enumerable<TEntity> implements IEnumerable<TEntity>\r\n{\r\n    private _name: string = null;\r\n\r\n    protected _operations: Operations<TEntity>;\r\n    \r\n    constructor(items?: Array<TEntity>) \r\n    constructor(items?: Iterable<TEntity>) \r\n    constructor(items?: AsyncIterable<TEntity>)\r\n    constructor(private items?: any) {\r\n        this._operations = new Operations<TEntity>();\r\n\r\n        this.from(items);\r\n    }\r\n\r\n    public get name(): string {\r\n        if (this._name != null)\r\n            return this._name;\r\n\r\n        if(this.items)\r\n            return this.items.constructor.name;\r\n\r\n        return \"\";\r\n    }\r\n\r\n    public get operations(): Operations<TEntity> {\r\n        return this._operations;\r\n    }\r\n\r\n    /**\r\n     * A remapper of identifier names, members is seperated with dot.\r\n     * @param remapper Function that returns the new name of the identifier\r\n     */\r\n    public remap<TResult>(remapper: (name: string) => string) : IEnumerable<TResult>\r\n    /**\r\n     * A remapper of values that corresponds to a identifier name\r\n     * @param remapper Function that returns the new value\r\n     */\r\n    public remap<TResult>(remapper: (name: string, value: any) => any) : IEnumerable<TResult>\r\n    public remap<TResult>(remapper: (...args) => any) : IEnumerable<TResult> {\r\n        let visitor = remapper.length == 2 ? new RemapVisitor(null, remapper) : new RemapVisitor(remapper, null);\r\n    \r\n        for (let item of this._operations.values()) {\r\n            switch (item.type) {\r\n                case OperatorType.Where:\r\n                    (<WhereOperator<TEntity>>item).expression = visitor.visit((<WhereOperator<TEntity>>item).expression);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return this as any;\r\n    }\r\n\r\n    /**\r\n     * Where clause using OData $filter expression returning either true or false. Any parameters used is properties of TEntity\r\n     * @param predicate OData expression\r\n     */\r\n    public where(predicate: string): this \r\n    /**\r\n     * Where clause using Javascript expression returning either true or false\r\n     * @param predicate javascript expression\r\n     * @param parameters any javascript parameters has to be declared\r\n     */\r\n    public where(predicate: (it: TEntity, ...param: any[]) => boolean, ...parameters: any[]): this\r\n    public where(): this {\r\n        let predicate: any = arguments[0],\r\n            parameters: Array<any> = [];\r\n\r\n        if (arguments.length >= 2)\r\n            parameters = Array.from(arguments).slice(1)\r\n\r\n        switch (typeof predicate) {\r\n            case 'string':\r\n                this._operations.add(new WhereOperator<TEntity>('OData', predicate));\r\n                break;\r\n\r\n            case 'function':\r\n                this._operations.add(new WhereOperator<TEntity>('Javascript', predicate, ...parameters));\r\n                break;\r\n\r\n            default:\r\n                throw new Error('Where operator can not recognize predicate either as javascript or odata');\r\n        }\r\n\r\n        return this;\r\n    }\r\n   \r\n    /**\r\n    * returns a new IEnumerable of TResult\r\n    * @param selector\r\n    */\r\n    public select<TResult>(selector: (it: TEntity) => TResult): IEnumerable<TResult> {\r\n        if (typeof this.items == 'object' && typeof this.items[Symbol.asyncIterator] == 'function') {\r\n            return new Enumerable<TResult>(new SelectOperator<TEntity>(selector).evaluateAsync(this));\r\n        } else {\r\n            return new Enumerable<TResult>(new SelectOperator<TEntity>(selector).evaluate(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * returns a new IEnumerable of TResult (Left Join)\r\n     * @param inner\r\n     * @param outerKey\r\n     * @param innerKey\r\n     * @param selector A function that returns the new object, (outer, inner) => { outer, inner } or (outer, inner) => Object.assign({}, a, { childs: inner.toArray() })\r\n     * @param indexing If set to true an Array of outerKey will be passed into iterator of TInner as { keys: Array<any> }. Cons, all elements of outer iterator will be be kept in memory.\r\n     * @returns IEnumerable<TResult>\r\n     */\r\n    public groupJoin<TInner, TResult>(inner: Iterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing?: boolean): IEnumerable<TResult>\r\n    /**\r\n     * returns a new IEnumerable of TResult (Left Join)\r\n     * @param inner\r\n     * @param outerKey\r\n     * @param innerKey\r\n     * @param selector A function that returns the new object, (outer, inner) => { outer, inner } or (outer, inner) => Object.assign({}, a, { childs: inner.toArray() })\r\n     * @param indexing If set to true an Array of outerKey will be passed into iterator of TInner as { keys: Array<any> }. Cons, all elements of outer iterator will be be kept in memory.\r\n     * @returns IEnumerable<TResult>\r\n     */\r\n    public groupJoin<TInner, TResult>(inner: AsyncIterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing?: boolean): IEnumerable<TResult> \r\n    public groupJoin<TInner, TResult>(inner: Iterable<TInner> | AsyncIterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing: boolean = false): IEnumerable<TResult> {\r\n        let iterable: Iterable<TInner> | AsyncIterable<TInner> = ((scope) => <any>{\r\n            [Symbol.asyncIterator]: (options) => {\r\n                return inner[Symbol.asyncIterator](Object.assign({ parent: scope }, options));\r\n            },\r\n            [Symbol.iterator]: (options) => {\r\n                return inner[Symbol.iterator](Object.assign({ parent: scope }, options));\r\n            }\r\n        })(this);\r\n\r\n        if (typeof inner == 'object' && typeof inner[Symbol.asyncIterator] == 'function') {\r\n            return new Enumerable<TResult>(new JoinOperator<TEntity, TInner, TResult>(JoinType.Left, outerKey, innerKey, selector, indexing).evaluateAsync(this, <AsyncIterable<TInner>>iterable));\r\n        } else {\r\n            return new Enumerable<TResult>(new JoinOperator<TEntity, TInner, TResult>(JoinType.Left, outerKey, innerKey, selector, indexing).evaluate(this, <Iterable<TInner>>iterable));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * returns a new IEnumerable of TResult (Inner Join)\r\n     * @param inner\r\n     * @param outerKey\r\n     * @param innerKey\r\n     * @param selector A function that returns the new object, (outer, inner) => { outer, inner } or (outer, inner) => Object.assign({}, a, { childs: inner.toArray() })\r\n     * @param indexing If set to true an Array of outerKey will be passed into iterator of TInner as { keys: Array<any> }. Cons, all elements of outer iterator will be be kept in memory.\r\n     * @returns IEnumerable<TResult>\r\n     */\r\n    public join<TInner, TResult>(inner: Iterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing?: boolean): IEnumerable<TResult> \r\n    /**\r\n     * returns a new IEnumerable of TResult (Inner Join)\r\n     * @param inner\r\n     * @param outerKey\r\n     * @param innerKey\r\n     * @param selector A function that returns the new object, (outer, inner) => { outer, inner } or (outer, inner) => Object.assign({}, a, { childs: inner.toArray() })\r\n     * @param indexing If set to true an Array of outerKey will be passed into iterator of TInner as { keys: Array<any> }. Cons, all elements of outer iterator will be be kept in memory.\r\n     * @returns IEnumerable<TResult>\r\n     */\r\n    public join<TInner, TResult>(inner: AsyncIterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing?: boolean): IEnumerable<TResult>\r\n    public join<TInner, TResult>(inner: Iterable<TInner> | AsyncIterable<TInner>, outerKey: (outer: TEntity) => void, innerKey: (inner: TInner) => void, selector: (outer: TEntity, inner: IEnumerable<TInner>) => TResult, indexing: boolean = false): IEnumerable<TResult> {\r\n        let iterable: Iterable<TInner> | AsyncIterable<TInner> = ((scope) => <any>{\r\n            [Symbol.asyncIterator]: (options) => {\r\n                return inner[Symbol.asyncIterator](Object.assign({ parent: scope }, options));\r\n            },\r\n            [Symbol.iterator]: (options) => {\r\n                return inner[Symbol.iterator](Object.assign({ parent: scope }, options));\r\n            }\r\n        })(this);\r\n\r\n        if (typeof inner == 'object' && typeof inner[Symbol.asyncIterator] == 'function') {\r\n            return new Enumerable<TResult>(new JoinOperator<TEntity, TInner, TResult>(JoinType.Inner, outerKey, innerKey, selector, indexing).evaluateAsync(this, <AsyncIterable<TInner>>iterable));\r\n        } else {\r\n            return new Enumerable<TResult>(new JoinOperator<TEntity, TInner, TResult>(JoinType.Inner, outerKey, innerKey, selector, indexing).evaluate(this, <Iterable<TInner>>iterable));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a specified number of contiguous elements from the start of a sequence.\r\n     * @param count The number of elements to return\r\n     */\r\n    public take(count: number): this {\r\n        this._operations.add(new TakeOperator<TEntity>(count));\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Bypasses a specified number of elements in a sequence and then returns the remaining elements\r\n     * @param count The number of elements to skip before returning the remaining elements\r\n     */\r\n    public skip(count: number): this {\r\n        this._operations.add(new SkipOperator<TEntity>(count));\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Bypassing elements using OData $filter expression as long as specified condition is true and then returns the remaining elements\r\n     * @param predicate OData expression\r\n     */\r\n    public skipWhile(predicate: string): this \r\n    /**\r\n     * Bypassing elements using Javascript expression as long as specified condition is true and then returns the remaining elements\r\n     * @param predicate javascript expression\r\n     * @param parameters any javascript parameters has to be declared\r\n     */\r\n    public skipWhile(predicate: (it: TEntity, ...param: any[]) => boolean, ...parameters: any[]): this\r\n    public skipWhile(): this {\r\n        let predicate: any = arguments[0],\r\n            parameters: Array<any> = [];\r\n\r\n        if (arguments.length >= 2)\r\n            parameters = Array.from(arguments).slice(1)\r\n\r\n        switch (typeof predicate) {\r\n            case 'string':\r\n                this._operations.add(new SkipWhileOperator<TEntity>('OData', predicate));\r\n                break;\r\n\r\n            case 'function':\r\n                this._operations.add(new SkipWhileOperator<TEntity>('Javascript', predicate, ...parameters));\r\n                break;\r\n\r\n            default:\r\n                throw new Error('SkipWhile operator can not recognize predicate either as javascript or odata');\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public orderBy(property: (it: TEntity) => void): this {\r\n        this._operations.add(new OrderByOperator<TEntity>(property));\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Bypasses all elements before beginning and returns the remaining elements or up to the specified end\r\n     * @param begin zero-based index at which to begin extraction\r\n     * @param end zero-based index before which to end extraction\r\n     */\r\n    public slice(begin: number, end?: number): this\r\n    /**\r\n     * Bypasses all elements before beginning and returns the remaining elements\r\n     * Note: If the beginning is not an index it's up to the repository to handle slicing.\r\n     * @param token a token that indicates where to begin extraction\r\n     */\r\n    public slice(token: any): this\r\n    public slice(begin: any, end: number = undefined): this\r\n    {\r\n        this._operations.add(new SliceOperator<TEntity>(begin, typeof begin == 'number' ? end : undefined));\r\n\r\n        return this;\r\n    }\r\n    \r\n    public from(items: Array<TEntity>) : this\r\n    public from(items: Iterable<TEntity>) : this\r\n    public from(items: AsyncIterable<TEntity>) : this\r\n    public from(items: Array<TEntity> | Iterable<TEntity> | AsyncIterable<TEntity>): this {\r\n        if (items) {\r\n            if (this._name == null)\r\n                this._name = items.constructor.name;\r\n\r\n            this.items = items;\r\n\r\n            if (typeof items == 'object' && typeof items[Symbol.asyncIterator] == 'function') {\r\n                this[Symbol.iterator] = undefined; // this isn't an sync iterator, unmark it from IEnumerable\r\n                this[Symbol.asyncIterator] = this.asyncIterator;\r\n            }\r\n            else if (typeof items == 'object' && typeof items[Symbol.iterator] == 'function') {\r\n                this[Symbol.asyncIterator] = undefined; // this isn't an async iterator, unmark it from IEnumerable\r\n                this[Symbol.iterator] = this.iterator;\r\n            }\r\n            else {\r\n                throw new TypeError('Enumerable is instanced with a non-iterable object');\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public copy(): IEnumerable<TEntity> {\r\n        let enumerable = new Enumerable<TEntity>(this.items)\r\n\r\n        for(let operation of this.operations.values())\r\n            enumerable.operations.add(operation)\r\n\r\n        return enumerable\r\n    }\r\n\r\n    public first(items?: Array<TEntity>): TEntity {\r\n        if (items)\r\n            this.from(items);\r\n\r\n        let iteratorResult = this[Symbol.iterator]().next();\r\n        if (iteratorResult.done == false)\r\n            return iteratorResult.value;\r\n\r\n        return null;\r\n    }\r\n\r\n    public async firstAsync(items?: Array<TEntity>): Promise<TEntity> {\r\n        if (items)\r\n            this.from(items);\r\n\r\n        let iteratorResult = await this[Symbol.asyncIterator]().next();\r\n        if (iteratorResult.done == false)\r\n            return iteratorResult.value;\r\n\r\n        return null;\r\n    }\r\n\r\n    public toArray(items?: Iterable<TEntity>): Array<TEntity> {\r\n        if (items)\r\n            this.from(items);\r\n\r\n        let result: Array<TEntity> = [];\r\n        for (let item of this.iterator())\r\n            result.push(item);\r\n\r\n        return result;\r\n    }\r\n\r\n        \r\n    public async toArrayAsync(items?: Iterable<TEntity>): Promise<Array<TEntity>> {\r\n        if (items)\r\n            this.from(items);\r\n\r\n        let result: Array<TEntity> = [];\r\n        for await(let item of this.asyncIterator()) //.asyncIterator())\r\n            result.push(item);\r\n\r\n        return result;\r\n    }\r\n\r\n    public static fromArray<TEntity>(items?: Array<TEntity>): Enumerable<TEntity> {\r\n        return new Enumerable(items);\r\n    }\r\n\r\n    protected * iterator(options?: IEnumerableOptions<TEntity>): IterableIterator<TEntity> {\r\n        if (!options || options.query == null)\r\n            options = Object.assign(options || {}, { query: this });\r\n\r\n        let handleItems = function* (items: Iterable<TEntity>, operators: Array<Operator<TEntity>>, idx: number = null) { \r\n            if(idx == null) idx = operators.length - 1;\r\n            \r\n            switch(idx) {\r\n                case -1:\r\n                    yield* items; break;\r\n\r\n                case 0:\r\n                    yield* operators[idx].evaluate( items ); break;\r\n                \r\n                default:\r\n                    yield* operators[idx].evaluate( handleItems(items, operators, idx - 1) ); break;\r\n            }\r\n        }\r\n\r\n        yield* handleItems(this.items[Symbol.iterator](options), Array.from(this.operations.values()));\r\n    }\r\n\r\n    protected async * asyncIterator(options?: IEnumerableOptions<TEntity>): AsyncIterableIterator<TEntity> {\r\n        if (!options || options.query == null)\r\n            options = Object.assign(options || {}, { query: this });\r\n\r\n        let handleItems = async function* (items: AsyncIterable<TEntity>, operators: Array<Operator<TEntity>>, idx: number = null) { \r\n            if(idx == null) idx = operators.length - 1;\r\n            \r\n            switch(idx) {\r\n                case -1:\r\n                    for await (let item of items)\r\n                        yield item;\r\n                    \r\n                    break;\r\n\r\n                case 0:\r\n                    yield* operators[idx].evaluateAsync(items); break;\r\n                \r\n                default:\r\n                    yield* operators[idx].evaluateAsync(handleItems(items, operators, idx - 1)); break;\r\n            }\r\n        }\r\n\r\n        yield* handleItems(this.items[Symbol.asyncIterator](options), Array.from(this.operations.values()));        \r\n    }\r\n\r\n    [Symbol.asyncIterator] = (): AsyncIterableIterator<TEntity> => this.asyncIterator();\r\n    [Symbol.iterator] = (): IterableIterator<TEntity> => this.iterator();\r\n\r\n}\r\n\r\nexport default Enumerable;"]}